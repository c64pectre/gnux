;    sh: Shell for Commodore 64.
;    Copyright (C) 2026 C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/exehdr/ create an issue

;region Kernal internal

KERNAL_NNMI20 := $FE72                                  ; Kernal nnmi20 continuation of NMI handing.

;endregion

;region Memory areas

; Area 1: $0200-$0258 89 bytes Command line
AREA_1       := KVAR_BUF_BUFOFS
AREA_1_LAST  := KVAR_BUF_BUFOFS_LAST
AREA_1_SIZE  =  KVAR_BUF_BUFOFS_SIZE

; Area 2: $02A7-$02FF 89 bytes
AREA_2      := KVAR_UNUSED_1
AREA_2_LAST := KVAR_UNUSED_1_LAST
AREA_2_SIZE =  KVAR_UNUSED_1_SIZE

; Area 3: $0334-$033B 8 bytes - ABI
AREA_3      := KVAR_UNUSED_2
AREA_3_LAST := KVAR_UNUSED_2_LAST
AREA_3_SIZE =  KVAR_UNUSED_2_SIZE

; Area 4: $033C-$03FF 196 bytes
AREA_4      := KERNAL_TBUFFR
AREA_4_LAST := KVAR_UNUSED_3_LAST
AREA_4_SIZE =  AREA_4_LAST - AREA_4 + 1

;endregion

;region Memory layout

; Begin of ABI (Application Binary Interface)

; see the-abi-export.asm

; end of ABI

;;; Command line
COMMAND_LINE      := AREA_1
COMMAND_LINE_SIZE =  82
        .assert COMMAND_LINE_SIZE <= AREA_1_SIZE , error
COMMAND_LINE_LAST := COMMAND_LINE + COMMAND_LINE_SIZE

ARGV      := AREA_4 + 4                                 ; $0340 ; AREA_4 + 4
ARGV_0    := ARGV + 0                                   ; $0340 ; AREA_4 + 4
ARGV_0_LO := ARGV_0                                     ; $0340 ; AREA_4 + 4
ARGV_0_HI := ARGV_0 + 1                                 ; $0341 ; AREA_4 + 5
ARGV_1    := ARGV + 2                                   ; $0342 ; AREA_4 + 6
ARGV_1_LO := ARGV_1                                     ; $0342 ; AREA_4 + 6
ARGV_1_HI := ARGV_1 + 1                                 ; $0343 ; AREA_4 + 7
ARGV_2    := ARGV + 4                                   ; $0344 ; AREA_4 + 8
ARGV_2_LO := ARGV_2                                     ; $0344 ; AREA_4 + 8
ARGV_2_HI := ARGV_2 + 1                                 ; $0345 ; AREA_4 + 9
ARGV_3    := ARGV + 6                                   ; $0346 ; AREA_4 + 10
ARGV_3_LO := ARGV_3                                     ; $0346 ; AREA_4 + 10
ARGV_3_HI := ARGV_3 + 1                                 ; $0347 ; AREA_4 + 11
ARGV_4    := ARGV + 8                                   ; $0348 ; AREA_4 + 12
ARGV_4_LO := ARGV_4                                     ; $0348 ; AREA_4 + 12
ARGV_4_HI := ARGV_4 + 1                                 ; $0349 ; AREA_4 + 13
ARGV_5    := ARGV + 10                                  ; $034A ; AREA_4 + 14
ARGV_5_LO := ARGV_5                                     ; $034A ; AREA_4 + 14
ARGV_5_HI := ARGV_5 + 1                                 ; $034B ; AREA_4 + 15
ARGV_6    := ARGV + 12                                  ; $034C ; AREA_4 + 16
ARGV_6_LO := ARGV_6                                     ; $034C ; AREA_4 + 16
ARGV_6_HI := ARGV_6 + 1                                 ; $034D ; AREA_4 + 17
ARGV_7    := ARGV + 14                                  ; $034E ; AREA_4 + 18
ARGV_7_LO := ARGV_7                                     ; $034E ; AREA_4 + 18
ARGV_7_HI := ARGV_7 + 1                                 ; $034F ; AREA_4 + 19
ARGV_8    := ARGV + 16                                  ; $0350 ; AREA_4 + 20
ARGV_8_LO := ARGV_8                                     ; $0350 ; AREA_4 + 20
ARGV_8_HI := ARGV_8 + 1                                 ; $0351 ; AREA_4 + 21
ARGV_9    := ARGV + 18                                  ; $0352 ; AREA_4 + 22
ARGV_9_LO := ARGV_9                                     ; $0352 ; AREA_4 + 22
ARGV_9_HI := ARGV_9 + 1                                 ; $0353 ; AREA_4 + 23

; String buffer for disk command, directory, file. Need 40 bytes + 1 for NUL.
DISK_COMMAND_LENGTH = 41
DISK_COMMAND_TEXT               := AREA_4 + 24 + 19

; Disk status Max is 35 bytes
DISK_STATUS_LENGTH = 35
DISK_STATUS_TEXT                := AREA_4 + 24 + 19 + 41
DISK_STATUS_TEXT_CODE_0         := DISK_STATUS_TEXT + 0
DISK_STATUS_TEXT_CODE_1         := DISK_STATUS_TEXT + 1

;;; summary: Name of loaded program, if any (then LOADED_PROGRAM_NAME[0] == 0) $03A6-$03B4 (14 bytes)
LOADED_PROGRAM_NAME             := AREA_4 + 24 + 19 + 41 + 35
LOADED_PROGRAM_NAME_SIZE        = FILE_NAME_MAX_LENGTH + 1

; Save colors
SAVE_KVAR_COLOR                 := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1
SAVE_VIC_EC                     := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 1
SAVE_VIC_B0C                    := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 2
; NMI
SAVE_KERNAL_NMINV_LO            := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 3
SAVE_KERNAL_NMINV_HI            := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 4
SAVE_S                          := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 5
NMI_ENTRY_COUNT                 := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 6

IN_STATUS                       := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 7
OUT_STATUS                      := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 8

;endregion

;region Main

;;; summary: Main
.proc MAIN
    jsr INITIALIZE
    jsr RUN

    rts
.endproc

;endregion

;region Loop

;;; summary: Initialize
.proc INITIALIZE
    ; Save stack pointer
    tsx
    stx SAVE_S

    ldx # REGISTER_STACK
    stx RP
    stx FP

    ; Set border color
    lda CONFIG_BORDER_COLOR
    if_pl_then
        sta VIC_EC
    else_end

    ; Set background color
    lda CONFIG_BACKGROUND_COLOR
    if_pl_then
        sta VIC_B0C
    else_end

    ; Set foreground color
    lda CONFIG_FOREGROUND_COLOR_CHAR
    if_ne_then
        jsr KERNAL_CHROUT
    else_end

    ; Clear screen
    lda # PETSCII_CLR
    jsr KERNAL_CHROUT

    ; Set system and work device to default device (8)
    lda # DEFAULT_DEVICE
    sta GNUX_SYS_DEVICE
    sta GNUX_WORK_DEVICE

    ; Set to device number of current file, if any
    lda ZPKERNAL_FA
    if_ne_then
        sta GNUX_SYS_DEVICE
        sta GNUX_WORK_DEVICE
    else_end

    ; GNUX_PARGV = &ARGV
    lda # < ARGV
    sta GNUX_PARGV_LO
    lda # > ARGV
    sta GNUX_PARGV_HI

    lda # 0                                             ; A = 0 = FALSE = PETSCVII_NUL

    ; GNUX_ARGC = 0. Note: GNUX_ARGC_HI is always 0 because GNUX_ARGC_MAX = 10
    sta GNUX_ARGC_LO
    sta GNUX_ARGC_HI

    ; Reset NMI entry count
    sta NMI_ENTRY_COUNT

    ; Redirect input & output inactive
    sta GNUX_IN_FA                                      ; 0 = Keyboard
    sta GNUX_OUT_FA                                     ; 0 = Screen

    ; Set no program loaded
    sta LOADED_PROGRAM_NAME

    ; Save NMI handler
    lda KERNAL_NMINV_LO
    sta SAVE_KERNAL_NMINV_LO
    lda KERNAL_NMINV_HI
    sta SAVE_KERNAL_NMINV_HI

    ; Set our NMI handler
    ;lda # <MY_NMI_HANDLER
    ;sta KERNAL_NMINV_LO
    ;lda # >MY_NMI_HANDLER
    ;sta KERNAL_NMINV_HI

    rts
.endproc

;;; summary: Run loop
.proc RUN
    from_loop
        jsr RESET_FILE_IO

        lda # PETSCII_SHIFTED_MODE
        jsr KERNAL_CHROUT

        jsr SHOW_PROMPT
        jsr READ_COMMAND_LINE
        jsr PROCESS_COMMAND_LINE
    next
        jmp _loop
    end

    ; Does not come here
.endproc

;;; summary: Show prompt
;;; changed: A+ X- Y+
.proc SHOW_PROMPT
    from
        ldy # 0
    loop
        lda RESOURCE_ZSTRING_PROMPT,y
        beq _end
        jsr KERNAL_CHROUT
    next
        iny
        bne _loop
    end

    rts
.endproc

;;; summary: Read line from input (presumably keyboard)
;;; out:
;;;   COMMAND_LINE: One line of text, return replaced with nul.
;;; changed: A+ X+ Y+
.proc READ_COMMAND_LINE
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN                                ; A+ X+ Y- C+
        sta COMMAND_LINE , y 
        cmp # PETSCII_RETURN
        beq _end
    next
        iny
        bne _loop
    end

    jsr KERNAL_CHROUT                                   ; A- X- Y- C=0

    ; Replace RETURN with NUL
    lda # PETSCII_NUL
    sta COMMAND_LINE , y

    rts
.endproc

;endregion

;region Parsing

;;; summary: Process input text
;;; in:
;;;   COMMAND_LINE: Input text, nul terminated
;;; changed: A+ X+ Y+ AX+ CX+ BX+ DX+
;;; notes:
;;;   A command line is a series of argument values, separated by one or
;;;   more SPACE or NO_BREAK_SPACE; an argument may be deliniated by
;;;   quotation marks. Input redirection indicator is '<'. Output
;;;   redirection to a file indicator is '>'. Output redirection to the
;;;   printer is '>>'. Redirection file names can be quoted too.
;;;   We only need to inc DL (and not DH as well) because we will not cross the page.
.proc PROCESS_COMMAND_LINE
    ; GNUX_ARGC := 0
    ldy # 0
    sty GNUX_ARGC_LO
    ; GNUX_ARGC_HI is always 0

    from ITERATE_COMMAND_LINE
        ; POINTER TO BYTE DX := & COMMAND_LINE
        lda # < COMMAND_LINE
        sta DL
        lda # > COMMAND_LINE
        sta DH
    loop
        ; check Y = 0
        jsr SKIP_BLANKS                                 ; A+ X- Y-
        cmp # PETSCII_NUL
        beq ITERATE_COMMAND_LINE::_end                  ; NUL -> break

        ; Redirect input from file?
        cmp # PETSCII_LESS_THAN_SIGN
        if_eq_then
            ; Yes
            ; Skip '<'
            inc DL
            jsr REDIRECT_INPUT_FROM_FILE                ; A+ X+ Y+ AX+ BX+
            ldy # 0
            bcc ITERATE_COMMAND_LINE::_loop             ; OK -> continue

            ; Error redirecting input from file
            ldx ERROR_NUMBER_CANT_OPEN_INPUT_FILE
            jsr OUT_ERROR_X_NUMBER

            rts
        else_end

        ; Redirect output to file or printer?
        cmp # PETSCII_GREATER_THAN_SIGN
        if_eq_then
            ; Skip '>'
            inc DL
            ; check Y = 0
            lda [DX],y
            cmp # PETSCII_GREATER_THAN_SIGN
            if_eq_then
                ; Skip second '>'
                inc DL
                ; Redirect output to printer
                jsr REDIRECT_OUTPUT_TO_PRINTER          ; A+ X+ Y+ C+
                ldy # 0
                bcc ITERATE_COMMAND_LINE::_loop         ; OK -> continue

                ; Error redirecting output to printer
                ldx ERROR_NUMBER_PRINTER_NOT_PRESENT
                jsr OUT_ERROR_X_NUMBER

                rts
            else_end

            ; Redirect output to file
            jsr REDIRECT_OUTPUT_TO_FILE                 ; A+ X+ Y+ AX+ BX+ CX+ DX+
            ldy # 0
            bcc ITERATE_COMMAND_LINE::_loop             ; OK -> continue

            ; Error redirecting output to file
            ldx # ERROR_NUMBER_CANT_OPEN_OUTPUT_FILE
            jsr OUT_ERROR_X_NUMBER

            rts
        else_end

        ; We have the start of an argument.
        ; check A = [DX]
        ; check A != NUL and A != SPACE and A != NO_BREAK_SPACE
        ; Quotation mark?
        pha
            cmp # PETSCII_QUOTATION_MARK
            if_eq_then
                inc DL
            else_end

            jsr SET_ARGV                                ; A+ X- Y=0
        pla
        cmp # PETSCII_QUOTATION_MARK
        if_eq_then
            jsr SKIP_QUOTED                             ; A+ X- Y- Z=1 DL+
            beq _end                                    ; bra
        else
            jsr SKIP_UNQUOTED                           ; A+ X- Y- Z=1 DL+
        end

        ; check A = [DX]
        cmp # PETSCII_NUL
        beq ITERATE_COMMAND_LINE::_end                  ; NUL -> EOI -> break break

        ; A != NUL and (A = SPACE or A = NO_BREAK_SPACE or A = QUOTATION_MARK)
        lda # PETSCII_NUL
        ; check Y = 0
        sta [DX],y
        inc DL
    next
        bne ITERATE_COMMAND_LINE::_loop                 ; bra
    end

    ; Finished parsing input text
    ; Have we got any arguments?
    lda GNUX_ARGC_LO
    if_ne_then
        ; We have got arguments?
        ; BX: ZSTRING := ARGV[0] = COMMAND
        lda # 0
        jsr GET_BX_GNUX_PARGV_INDEX_A                        ; A+ X- Y+ BX+
        ldy # 0
        lda [BX],y
        ; Argument 0 not empty?
        if_ne_then
            try
                jsr TRY_BUILT_IN_COMMAND
                if_cs_then                              ; Not built-in command
                    jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
                    if_cc_then
                        jsr EXECUTE_PROGRAM
                    else_end
                else_end
            catch_finally_end
        else_end
    else_end

    jsr RESET_FILE_IO

    rts
.endproc

;;; summary: AX := ARGV[A]
;;; in:
;;;   A: Index 
;;; out:
;;;  AX: GNUX_PARGV[A]
;;; changed: A+ X- Y+ BX+
.proc GET_AX_GNUX_PARGV_INDEX_A
    ; AX := GNUX_PARGV[A]
    ldy GNUX_PARGV_LO
    sty AL
    ldy GNUX_PARGV_HI
    sty AH
    asl
    tay
    lda [AX],y
    tax
    iny
    lda [AX],y
    sta AH
    stx AL

    rts
.endproc

;;; summary: BX := ARGV[A]
;;; in:
;;;   A: Index 
;;; out:
;;;   BX: GNUX_PARGV[A]
;;; changed: A+ X- Y+ BX+
.proc GET_BX_GNUX_PARGV_INDEX_A
    ; BX := GNUX_PARGV[A]
    ldy GNUX_PARGV_LO
    sty BL
    ldy GNUX_PARGV_HI
    sty BH
    asl
    tay
    lda [BX],y
    tax
    iny
    lda [BX],y
    sta BH
    stx BL

    rts
.endproc

;;; summary: Skip SPACE and NO_BREAK_SPACE in command line
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   DX: Pointer advanced to non blank character (may be NUL)
;;;   Z: 1: *DX = NUL , 0: *DX != NUL
;;; changed: A+ X- Y- DL+
.proc SKIP_BLANKS
    ; check Y = 0

    from_loop
        ; A := [DX]
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_SPACE
        if_eq_then
            inc DL
            bne _loop                                   ; SPACE -> continue
        else_end

        cmp # PETSCII_NO_BREAK_SPACE
        if_eq_then
            inc DL
            bne _loop                                   ; NO_BREAK_SPACE -> continue
        else_end
    next_end

    rts
.endproc

;;; summary: Skip up to and including NUL, SPACE, NO_BREAK_SPACE.
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   A: = [DX]
;;;   A: = NUL or = SPACE or = NO_BREAK_SPACE
;;;;  Z: = 1
;;; changed: A+ X- Y- DL+
.proc SKIP_UNQUOTED
    ; check Y = 0

    from_loop
        ; A := [DX]
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_SPACE
        beq _end                                        ; SPACE -> break

        cmp # PETSCII_NO_BREAK_SPACE
        beq _end                                        ; NO_BREAK_SPACE -> break
    next
        inc DL
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Skip up to and including NUL, QUOTATION_MARK.
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   A: = NUL or = QUOTATION_MARK
;;;   Z: = 1
;;;   [DX]: = NUL or = QUOTATION_MARK
;;; changed: A+ X- Y- DL+
.proc SKIP_QUOTED
    ; check Y = 0

    from_loop
        ; A := *DX
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_QUOTATION_MARK
        beq _end                                        ; QUOTATION_MARK -> break
    next
        inc DL
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Set ARGV index GNUX_ARGC to pointer in input text
;;; in:
;;;   GNUX_ARGC: Argument count
;;;   DX: POINTER TO BYTE: Pointer in command line to start of argument text
;;; out:
;;;   Y: = 0
;;;   ARGV[GNUX_ARGC++]: = DX
;;; changed:
;;;   A+ X- Y=0
.proc SET_ARGV
    ; Y := GNUX_ARGC * SIZEOF(WORD) = GNUX_ARGC * 2 = GNUX_ARGC << 1
    lda GNUX_ARGC_LO
    asl
    tay
    ; POINTER TO WORD (ARGV + Y) := DX
    lda DL
    sta ARGV,y
    lda DH
    sta ARGV + 1,y
    inc GNUX_ARGC_LO

    ldy # 0

    rts
.endproc

;;; summary: Get (extract) file name from `COMMAND_LINE` from position `DX`.
;;; in:
;;;   DX: Pointer in command line, initially to the '>'. Advanced to after
;;; out:
;;;   AX: ZSTRING: DISK_COMMAND_TEXT: file name unquoted. May be empty.
;;; changed: A+ X- Y+ AX+ BX+ DL+
.proc GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE
    ; check Y = 0
    ; [DX] != NUL and [DX] != PETSCII_SPACE and [DX] != PETSCII_NO_BREAK_SPACE and [DX] != PETSCII_PETSCII_LESS_THAN_SIGN and [DX] != PETSCII_PETSCII_GREATER_THAN_SIGN

    ; ""
    jsr ZSTRING_AX_INIT_DISK_COMMAND_TEXT               ; A+ X- Y- AX+

    ; Skip blanks
    jsr SKIP_BLANKS                                     ; A+ X- Y=0 DL+
    cmp # PETSCII_NUL
    if_eq_then
        ; Empty string
        sec                                             ; FAIL
        rts
    else_end

    ; A = [DX]

    ; check Y = 0
    ; check A != NUL and A != SPACE and A != NO_BREAK_SPACE
    ; A is quotation mark or not
    pha
        cmp # PETSCII_QUOTATION_MARK
        if_eq_then
            inc DL
        else_end

        ; BX := DX
        lda DL
        sta BL
        lda DH
        sta BH
    pla
    cmp # PETSCII_QUOTATION_MARK
    if_eq_then
        jsr SKIP_QUOTED                                 ; A+ X- Y- Z1 DL+
        beq _end                                        ; bra
    else
        jsr SKIP_UNQUOTED                               ; A+ X- Y- Z+ DL+
    end

    cmp # PETSCII_NUL
    if_ne_then
        ; A = SPACE or A = NO_BREAK_SPACE or A = QUOTATION_MARK
        lda # PETSCII_NUL
        sta [DX],y
        inc DL
    else_end
 
    jsr ZSTRING_BX_COPY_TO_ZSTRING_AX                   ; A+ X- Y+

    clc                                                 ; OK

    rts
.endproc

;endregion

;region Redirection

;;; summary: redirect input from file named `FILE_NAME_TEXT` extracted from `COMMAND_LINE` on work disk
;;; in:
;;;   COMMAND_LINE: Input text
;;;   X: Position in COMMAND_LINE
;;;   Y: Offset in ARGV
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ AX+ BX+
;;; notes: Need to preserve X & Y for PROCESS_COMMAND_LINE
.proc REDIRECT_INPUT_FROM_FILE
    ; check Y = 0

    lda GNUX_IN_FA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    jsr GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE      ; A+ X- Y+ AX+
    if_cc_then
        lda # REDIRECT_INPUT_FA
        ldx GNUX_WORK_DEVICE
        ldy # REDIRECT_INPUT_SA
        jsr OPEN_IN_FILE_AX                             ; A+ X+ Y+ C+

       ;ldx GNUX_WORK_DEVICE
       ;lda # PROCESS_DISK_STATUS_OPEN | PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW
       ;jsr PROCESS_DISK_STATUS
    else_end

    rts
.endproc

;;; summary: Redirect output to file named `FILE_NAME_TEXT` extracted from `COMMAND_LINE` on work disk
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DX+
;;; notes:
;;;   We must preserve DX
.proc REDIRECT_OUTPUT_TO_FILE
    ; check Y = 0

    lda GNUX_OUT_FA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    ; AX := FILE
    jsr GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE      ; A+ X- Y+ AX+ DX+
    if_cc_then
        ; + ",s,w"
        ldx # < RESOURCE_ZSTRING_SEQ_WRITE
        ldy # > RESOURCE_ZSTRING_SEQ_WRITE
        jsr ZSTRING_AX_APPEND_ZSTRING_XY_USING_BX       ; A+ X- Y+ BX+ CX+
        ; Open
        lda # REDIRECT_OUTPUT_FA
        ldx GNUX_WORK_DEVICE
        ldy # REDIRECT_OUTPUT_FILE_SA
        jsr OPEN_OUT_FILE_AX                            ; A+ X+ Y+ CX+ dfltn=0 dflto=3

       ;ldx GNUX_WORK_DEVICE
       ;lda # PROCESS_DISK_STATUS_OPEN | PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW
       ;jsr PROCESS_DISK_STATUS
    else_end

    rts
.endproc

;;; summary: Redirect output to printer (device 4, secondary address 7 is upper and lower case charecters)
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ AX+
.proc REDIRECT_OUTPUT_TO_PRINTER
    lda GNUX_OUT_FA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    ; check GNUX_OUT_FA = 0

    ; Open with no name
    jsr ZSTRING_AX_INIT_DISK_COMMAND_TEXT               ; A+ X- Y- AX+
    lda # REDIRECT_OUTPUT_FA
    ldx # REDIRECT_OUTPUT_PRINTER_DA
    ldy # REDIRECT_OUTPUT_PRINTER_SA
    jsr OPEN_OUT_FILE_AX                                ; A+ X+ Y+ C+

    rts
.endproc

;endregion

;region Execution

;;; summary: Try built-in command
;;; in:
;;;   BX: ZSTRING: Candidate command
;;; changed: A+ X+ Y+ BX+ DX+
.proc TRY_BUILT_IN_COMMAND
    jsr MAP_COMMAND_NAME_TO_COMMAND_NUMBER              ; X = command number if Z=1
    if_ne_then
        sec                                             ; Not built-in command
        rts
    else_end

    try
        lda TABLE_COMMAND_HANDLER_LO,x
        sta DL
        lda TABLE_COMMAND_HANDLER_HI,x
        sta DH

        jsr JSR_INDIRECT_DX

        clc
        php
        bcc _finally
    catch
        sec
        php
    finally
        plp
    end

    rts
.endproc

;;; summary: Execute loaded program
;;; notes:
;;;   Entry point is at $1800
;;; changed: A+ X+ Y+ AX+ RP+ FP+
.proc EXECUTE_PROGRAM
    try
        ; Save colors
        lda KVAR_COLOR
        sta SAVE_KVAR_COLOR
        lda VIC_EC
        sta SAVE_VIC_EC
        lda VIC_B0C
        sta SAVE_VIC_B0C

        ; Call program's entrypoint, passing GNUX_ARGC and ARGV arguments.
        ldx # REGISTER_STACK
        stx RP
        lda GNUX_ARGC_LO
        sta 0,x
        inx
        lda GNUX_ARGC_HI
        sta 0,x
        inx
        lda GNUX_PARGV_LO
        sta 0,x
        inx
        lda GNUX_ARGC_HI
        sta 0,x
        inx
        stx RP
        stx FP
        jsr PROGRAM_ENTRYPOINT

        ; Restore colors
        lda SAVE_VIC_EC
        sta VIC_EC
        lda SAVE_VIC_B0C
        sta VIC_B0C
        lda SAVE_KVAR_COLOR
        sta KVAR_COLOR
        jsr FILL_COLOR_SCREEN_A
    catch_finally_end

    rts
.endproc

;;; summary: Fill color screen
;;; in:
;;;   A: BYTE: Color
;;; changed:
;;;   A- X+ Y-
.proc FILL_COLOR_SCREEN_A
    from
        ldx # 250
    loop
        sta SCREEN_COLOR_RAM_BASE       - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 250 - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 500 - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 750 - 1 , x
    next
        dex
        bne _loop
    end

    rts
.endproc

;endregion

;region Loading

;;; summary: Load program with, if not already done so.
;;; in:
;;;   BX: Name of program to load.
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ AX+
.proc LOAD_PROGRAM_IF_NOT_ALREADY_LOADED
    ; Already loaded?
    lda # < LOADED_PROGRAM_NAME
    sta AL
    lda # > LOADED_PROGRAM_NAME
    sta AH
    jsr ZSTRING_AX_COMPARE_ZSTRING_BX                   ; A+ X- Y+ Z+
    if_eq_then
        clc                                             ; OK
        rts
    else_end

    jsr LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK

    rts
.endproc

;;; summary: Load program from work disk or else from system disk
;;; in:
;;;   BX: ZSTRING: Name of program to load.
;;; out:
;;;   C: 0=OK 1=FAIL
.proc LOAD_PROGRAM_FROM_WORK_OR_SYS_DISK
    ; Try work disk
    ldx GNUX_WORK_DEVICE
    jsr LOAD_PROGRAM
    if_cs_then
        ; Load from work disk failed.
        ; Try system disk
        ldx GNUX_SYS_DEVICE
        jsr LOAD_PROGRAM
        if_cs_then
            ; Load from system disk failed too.
            ldx # ERROR_NUMBER_COMMAND_NOT_FOUND
            jsr OUT_ERROR_X_NUMBER

            rts
        else_end
    else_end

    ; Save name of loaded program.
    ; notes: We know program name is max 16 characters + 1 for NUL
    lda # < LOADED_PROGRAM_NAME
    sta AL
    lda # > LOADED_PROGRAM_NAME
    sta AH
    jsr ZSTRING_BX_COPY_TO_ZSTRING_AX                   ; A+ X- Y+

    clc                                                 ; OK

    rts
.endproc

;;; summary: Load program
;;; in:
;;;   X: UBYTE: DEVICE
;;;   BX: ZSTRING: COMMAND
;;; changed: A+ X+ Y+ AX+ DX+
;;; notes:
;;;   BX is not changed because caller may want to save the file name if loaded.
.proc LOAD_PROGRAM
    ; check BX.LENGTH <= FILE_NAME_MAX_LENGTH

    stx DL                                              ; DL = X = DEVICE

    ; AX := ""
    jsr ZSTRING_AX_INIT_DISK_COMMAND_TEXT               ; A+ X- Y- AX+

    ; + COMMAND
    jsr ZSTRING_AX_APPEND_ZSTRING_BX                    ; A+ X- Y+

    ; + ".sh"
    jsr ZSTRING_AX_APPEND_DOT_SH                        ; A+ X+ Y+

    ; Load
    lda # LOAD_FA
    ldy # LOAD_SA
    ldx DL                                              ; X = DL = DEVICE
    jsr KERNAL_SETLFS
    jsr ZSTRING_AX_LENGTH
    tya
    ldx AL
    ldy AH
    jsr KERNAL_SETNAM
    ldx DL                                              ; X = DL = DEVICE
    lda # KERNAL_LOAD_LOAD
    jsr KERNAL_LOAD                                     ; No need to close
    if_cc_then
        rts                                             ; OK
    else_end

    ; C = 1
    ; Load error
    cmp # KERNAL_ERROR_DEVICE_NOT_PRESENT
    if_eq_then
        ; Device not present
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        sec
        rts
    else_end

    ; Device present. (Attempt to) read (but not show) disk status.
    ldx DL                                              ; X = DL = DEVICE
    lda # PROCESS_DISK_STATUS_OPEN | PROCESS_DISK_STATUS_CLOSE
    jsr PROCESS_DISK_STATUS

    sec                                                 ; FAIL

    rts
.endproc

;;; summary: Append ".sh" to ZSTRING AX
;;; in:
;;;   AX: ZSTRING: Target string
;;; changed: A+ X+ Y+
;;; notes:
;;;   We did not have any more free registers in `LOAD_PROGRAM` so we could
;;;   not use a generic routine instead.
.proc ZSTRING_AX_APPEND_DOT_SH
    jsr ZSTRING_AX_LENGTH
    from
        ldx # 0
    loop
        lda RESOURCE_STRING_DOT_SH,x
        beq _end                                        ; break
        sta [AX],y
        iny
    next
        inx
        bne _loop                                       ; bra
    end

    lda # PETSCII_NUL
    sta [AX],y

    rts
.endproc

;endregion

;region Disk status

;;; sumary: Process disk status:
;;; in:
;;;   X: Device address
;;;   A: PROCESS_DISK_STATUS_* flags
;;; out:
;;;   C: 0=OK 1=ERROR
;;; changed: A+ X+ Y+ C+
.proc PROCESS_DISK_STATUS
    pha
        clc                                             ; C0
        and # PROCESS_DISK_STATUS_OPEN                  ; A+ N+ Z+
        if_ne_then
            jsr OPEN_DISK_COMMAND_STATUS_CHANNEL        ; A+ X+ Y+ C+
        else_end

        if_cc_then
            jsr READ_DISK_STATUS                        ; A+ X+ Y+ C+
        else_end

        if_cc_then
            ; Check disk status: "00" is OK, else is error
            jsr CHECK_DISK_STATUS                       ; A+ X- Y- C+
            if
                pla
                pha
                and # PROCESS_DISK_STATUS_SHOW          ; A+ N+ Z+
                beq _end                                ; ~SHOW -> No
                pla
                pha
                and # PROCESS_DISK_STATUS_ALWAYS        ; A+ N+ Z+
                bne _then                               ; ALWAYS -> Yes
                bcc _end                                ; C=0 -> No
                ; check C=1                             ; Yes
            then
                jsr OUT_DISK_STATUS                     ; A+ X+ Y- P-
                ; check C=1
            else_end
        else_end
    pla
    and # PROCESS_DISK_STATUS_CLOSE                     ; A+ N+ Z+
    if_ne_then
        jsr CLOSE_DISK_COMMAND_STATUS_CHANNEL           ; A+ X+ Y+ P-
    else_end

    rts
.endproc

;;; summary: Open disk command and status channel
;;; in:
;;;   X: DEVICE
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y- C+
;;; notes: Basically never fails because there is no file name
.proc OPEN_DISK_COMMAND_STATUS_CHANNEL
    lda # 0
    jsr KERNAL_SETNAM                                   ; A- X- Y-
    lda # DISK_COMMAND_FA_SA
    tay
    jsr KERNAL_SETLFS                                   ; A=FA X=DA Y=SA | A- X- Y-
    jsr KERNAL_OPEN                                     ; A+ X+ Y- C+

    rts
.endproc

;;; summary: Close disk command and status channel
;;; changed: A+ X+ Y+ P-
.proc CLOSE_DISK_COMMAND_STATUS_CHANNEL
    php
        lda # DISK_COMMAND_FA
        jsr KERNAL_CLOSE                                ; A+ X+ Y+ C+
        jsr CLRCHN                                      ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0
    plp

    rts
.endproc

;;; summary: Read disk status of device `A` into `DISK_STATUS_TEXT`.
;;; in:
;;;   X: DEVICE
;;; out:
;;;   C: 0=OK 1=ERROR
;;;   DISK_STATUS_TEXT: Disk status that has been read
;;; changed: A+ X+ Y+ C+
.proc READ_DISK_STATUS
    ; DISK_STATUS_TEXT = ""
    lda # PETSCII_NUL
    sta DISK_STATUS_TEXT

    ; Set input
    ldx # DISK_COMMAND_FA
    jsr KERNAL_CHKIN                                    ; A+ X+ Y- C+
    if_cs_then
        ; Cannot read disk status
        rts
    else_end

    ; Read line
    try
        from
            ldy # 0
        loop
            jsr KERNAL_CHRIN                            ; out A=RESULT | A+ X+ Y- C0 V+ N+ Z+
            ldx ZPKERNAL_STATUS
            bne _catch                                  ; Error -> throw
            cmp # PETSCII_RETURN
            beq _end                                    ; break
            sta DISK_STATUS_TEXT , y
        next
            iny
            bne _loop
        end
    catch_finally_end

    lda # PETSCII_NUL
    sta DISK_STATUS_TEXT , y

    ; Last chrin causes EOI and C=1

    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0

    rts
.endproc

;;; summary: Check disk status text for errors
;;; out:
;;;   C: 0=OK , 1=ERROR
;;; changed: A+ X- Y- C+
.proc CHECK_DISK_STATUS
    if
        lda DISK_STATUS_TEXT_CODE_0
        cmp # PETSCII_DIGIT_ZERO                        ; C+ N+ Z+
        bne _then
        lda DISK_STATUS_TEXT_CODE_1
        cmp # PETSCII_DIGIT_ZERO                        ; C+ N+ Z+
        beq _end
    then
        ; ! (DISK_STATUS_TEXT_CODE_0 = "0" & DISK_STATUS_TEXT_CODE_1 = "0")
        sec                                             ; ERROR

        rts
    else_end

    clc                                                 ; OK

    rts
.endproc

;;; summary: Print disk status
;;; changed: A+ X+ Y- P-
.proc OUT_DISK_STATUS
    php
        from
            ldx # 0
        loop
            lda DISK_STATUS_TEXT , x
            jsr KERNAL_CHROUT                           ; A- X- Y- C0
            cmp # PETSCII_NUL
            beq _end                                    ; break
        next
            inx
            bne _loop                                   ; bra
        end

        lda # PETSCII_RETURN
        jsr KERNAL_CHROUT                               ; A- X- Y- C0
    plp

    rts
.endproc

;endregion

;region Build-in commands

.proc CMD_EXIT
    ; Reset kernal indirects and vectors to system defaults
    jsr KERNAL_RESTOR                                   ; A+ X+ Y+

    ldx SAVE_S
    txs

    rts
.endproc

;;; summary: Load program
;;; in:
;;;   ARGV[1]: Program name
.proc CMD_LOAD
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; BX := ARGV[1]
    lda # 1
    jsr GET_BX_GNUX_PARGV_INDEX_A
    jsr ZSTRING_BX_LENGTH
    cpy # 0
    if_eq_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER

        rts
    else_end

    cpy # COMMAND_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    jsr LOAD_PROGRAM_IF_NOT_ALREADY_LOADED              ; in BX

    rts
.endproc

.proc CMD_LS
    ldx GNUX_SYS_DEVICE
    jsr CMD_DIR
    rts
.endproc

.proc CMD_L
    ldx GNUX_WORK_DEVICE
    jsr CMD_DIR
    rts
.endproc

;;; summary: Send command to work disk
;;; changed: A+ X+ Y+ AX+
.proc CMD_DISK
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX : ZSTRING := ARGV[1]
    lda # 1
    jsr GET_AX_GNUX_PARGV_INDEX_A
    ; Y := AX.LENGTH
    jsr ZSTRING_AX_LENGTH
    if
        cpy # 0
        beq _then
        cpy # DISK_COMMAND_MAX_LENGTH + 1
        bcc _end                                        ; lt
    then                                                ; ge
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; Open
    ldx GNUX_WORK_DEVICE
    jsr OPEN_DISK_COMMAND_STATUS_CHANNEL                ; A+ X+ Y+ C+

    ; Set output
    ldx # DISK_COMMAND_FA
    jsr CHKOUT                                          ; A- X- Y- C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    jsr OUT_PUT_STRING_ZSTRING_AX

    ; Necessary
    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW | PROCESS_DISK_STATUS_ALWAYS
    jsr PROCESS_DISK_STATUS

    rts
.endproc

;;; summary: Remove (delete, scratch) file
;;; changed: A+ X+ Y+ AX+
.proc CMD_RM
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX := = ARGV[1]
    lda # 1
    jsr GET_AX_GNUX_PARGV_INDEX_A
    jsr ZSTRING_AX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_eq_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ldx GNUX_WORK_DEVICE
    jsr OPEN_DISK_COMMAND_STATUS_CHANNEL                ; A+ X+ Y+

    ldx # DISK_COMMAND_FA
    jsr CHKOUT                                          ; A- X- Y- C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; "s"
    lda # PETSCII_LATIN_LETTER_S
    jsr KERNAL_CHROUT

    ; ":"
    lda # PETSCII_COLON
    jsr KERNAL_CHROUT

    jsr OUT_PUT_STRING_ZSTRING_AX

    ; Necessary
    jsr CLRCHN                                          ; A+ X+ Y- C=1 DFLTN=0 DFLTO=3

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS

    rts
.endproc

;;; summary: Move (rename) file
;;; changed: A+ X+ Y+ AX+
.proc CMD_MV
    lda GNUX_ARGC_LO
    cmp # 3
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX = ARGV[1] = FROM
    lda # 1
    jsr GET_AX_GNUX_PARGV_INDEX_A
    jsr ZSTRING_AX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; BX = ARGV[2] = TO
    lda # 2
    jsr GET_BX_GNUX_PARGV_INDEX_A
    jsr ZSTRING_BX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ldx GNUX_WORK_DEVICE
    jsr OPEN_DISK_COMMAND_STATUS_CHANNEL                ; A+ X+ Y+

    ldx # DISK_COMMAND_FA
    jsr KERNAL_CHKOUT                                   ; A+ X+ Y+ C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; "r"
    lda # PETSCII_LATIN_LETTER_R
    jsr KERNAL_CHROUT

    ; ":"
    lda # PETSCII_COLON
    jsr KERNAL_CHROUT

    ; TO
    jsr OUT_PUT_STRING_ZSTRING_BX

    ; "="
    lda # PETSCII_EQUALS_SIGN
    jsr KERNAL_CHROUT

    ; FROM
    jsr OUT_PUT_STRING_ZSTRING_AX

    ; Necessary
    jsr CLRCHN                                          ; A+ X+ Y- C=1 DFLTN=0 DFLTO=3

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS

    rts
.endproc

;;; summary: Print (cat) file
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DX+
.proc CMD_CAT
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; Like Gnu cat, close IN redirection if we have got a file
    lda GNUX_IN_FA
    if_ne_then
        jsr CLOSE                                       ; Does CLRCHN too
    else_end

    ; BX := ARGV[1]
    lda # 1
    jsr GET_BX_GNUX_PARGV_INDEX_A                       ; A+ X- Y+ BX+
    jsr ZSTRING_BX_LENGTH
    if
        cpy # 0
        beq _then
        cpy # FILE_NAME_MAX_LENGTH + 1
        bcc _end                                        ; lt
    then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ; Open
    lda # REDIRECT_INPUT_FA
    ldy # REDIRECT_INPUT_SA
    ldx GNUX_WORK_DEVICE
    jsr OPEN_IN_FILE_BX                                 ; A+ X+ Y+ C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_OPEN | PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN
    if_cs_then
        rts
    else_end

    jsr STREAM_COPY_IN_TO_OUT
    ; TODO: check errors?

    lda # REDIRECT_INPUT_FA
    jsr CLOSE                                           ; A+ X+ Y+ C0

    lda # REDIRECT_OUTPUT_FA
    jsr CLOSE                                           ; A+ X+ Y+ C0

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_CLOSE | PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS
    rts
.endproc

;;; summary: Show or change work disk
.proc CMD_WORK
    ; DX: POINTER TO UBYTE := & GNUX_SYS_DEVICE
    lda # < GNUX_WORK_DEVICE
    sta DL
    lda # > GNUX_WORK_DEVICE
    sta DH
    jsr SHOW_OR_CHANGE_DEVICE

    rts
.endproc

;;; summary: Show or change system disk
.proc CMD_SYS
    ; DX: POINTER TO UBYTE := & GNUX_SYS_DEVICE
    lda # < GNUX_SYS_DEVICE
    sta DL
    lda # > GNUX_SYS_DEVICE
    sta DH
    jsr SHOW_OR_CHANGE_DEVICE

    rts
.endproc

;endregion

;region Implementation of CMD_L and CMD_LS

;;; summary: Directory listing of work or system disk
;;; in:
;;;   X: DEVICE
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DL+
.proc CMD_DIR
    lda GNUX_ARGC_LO
    cmp # 3
    if_ge_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    stx DL                                              ; DL = X = DEVICE

    ; ""
    jsr ZSTRING_AX_INIT_DISK_COMMAND_TEXT               ; A+ X- Y- AX+

    ; + "$"
    lda # PETSCII_DOLLAR
    jsr ZSTRING_AX_APPEND_CHAR_A                        ; A+ X- Y+

    lda GNUX_ARGC_LO
    cmp # 2
    if_eq_then
        ; BX :=  ARGV[1]
        lda # 1
        jsr GET_BX_GNUX_PARGV_INDEX_A
        jsr ZSTRING_BX_LENGTH                           ; A+ X- Y+
        cpy # FILE_NAME_MAX_LENGTH + 1
        if_ge_then
            ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
            jsr OUT_ERROR_X_NUMBER
            rts
        else_end
        ; + ":"
        lda # PETSCII_COLON
        jsr ZSTRING_AX_APPEND_CHAR_A                    ; A+ X- Y+

        ; + PATTERN
        jsr ZSTRING_AX_APPEND_ZSTRING_BX                ; A+ X- Y+
    else_end

    ldx DL                                              ; X = DL = DEVICE
    lda # FILE_FA
    ldy # 0                                             ; SA load indicator
    jsr OPEN_IN_FILE_AX                                 ; in A=FA X=DA Y=0=LOAD AX=FILENAME | A+ X+ Y+ C+ DFLTN=0 DFLTO=3
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER
        rts
    else_end

    ldx DL                                              ; A = DL = DEVICE
    lda # PROCESS_DISK_STATUS_OPEN | PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS
    if_cs_then
        rts
    else_end

    try
        ; Load address
        ; Reading the first two bytes never gives error, so we need not check.
        jsr IN_CHKIN
        jsr KERNAL_CHRIN                                ; A+ X+ Y- C0 N+ V+ Z+
        jsr KERNAL_CHRIN                                ; A+ X+ Y- C0 N+ V+ Z+

        jsr OUT_CHKOUT                                  ; A+ X+ Y+ C+
        lda # PETSCII_RETURN
        jsr KERNAL_CHROUT                               ; A+ X+ Y- C0 N+ V+ Z+

        from_loop OUTER
            jsr IN_CHKIN
            jsr KERNAL_CHRIN                            ; A+ X+ Y- C0 N+ V+ Z+
            beq OUTER::_end                             ; End of directory -> break
            jsr KERNAL_CHRIN                            ; A+ X+ Y- C0 N+ V+ Z+

            jsr KERNAL_CHRIN                            ; A+ X+ Y- C0 N+ V+ Z+
            sta AL
            jsr KERNAL_CHRIN                            ; A+ X+ Y- C0 N+ V+ Z+
            sta AH
            jsr AX_UWORD_TO_DECIMAL_AX_BX_CX            ; A+ X+ Y+ AX+ BX+ CX+

            jsr KERNAL_CHROUT                           ; A+ X+ Y- C0 N+ V+ Z+
            jsr OUT_PUT_ZSTRING_AX_BX_CX
            lda # PETSCII_SPACE
            jsr KERNAL_CHROUT
            from_loop INNER
                jsr IN_CHKIN
                jsr KERNAL_CHRIN
                ldx ZPKERNAL_STATUS
                bne OUTER::_end                         ; EOI -> break
                bit ZPKERNAL_STATUS
                bvs OUTER::_end                         ; EOI -> break
                cmp # PETSCII_NUL
                beq INNER::_end                         ; break

                jsr OUT_CHKOUT                          ; A- X- Y- C+
                jsr KERNAL_CHROUT
            next
                jmp INNER::_loop
            end

            jsr OUT_CHKOUT                              ; A- X- Y- C+
            lda # PETSCII_RETURN
            jsr KERNAL_CHROUT

            ; STOP key pressed?
            jsr KERNAL_STOP
            beq _end                                    ; STOP key was pressed -> break

            jsr PAUSE_ON_SHIFT                          ; A+ X- Y-
        next
            jmp _loop
        end

        jsr OUT_CHKOUT                                  ; A- X- Y- C+
        lda # PETSCII_RETURN
        jsr KERNAL_CHROUT
    catch_finally
        lda # FILE_FA
        jsr CLOSE
    end

    rts
.endproc

;endregion

;region Implementation of work and sys

;;; summary: Show or change work or system device
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;; changed: A+ X+ Y+ AX+ BX+
.proc SHOW_OR_CHANGE_DEVICE
    lda GNUX_ARGC_LO
    cmp # 1
    if_eq_then
        ; Show
        jsr SHOW_DEVICE

        rts
    else_end

    cmp # 2
    if_eq_then
        jsr CHANGE_DEVICE

        rts
    else_end

    ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
    jsr OUT_ERROR_X_NUMBER

    rts
.endproc

;;; summary: Show device number
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;; changed: A+ X+ Y+ AX+ BX+
.proc SHOW_DEVICE
    jsr OUT_CHKOUT                                      ; A- X- Y- C+
    ldx # < RESOURCE_ZSTRING_DEVICE
    ldy # > RESOURCE_ZSTRING_DEVICE
    jsr OUT_PUT_STRING_XY_USING_AX

    ; A: UBYTE := [DX]                                  ; DEVICE
    ldy # 0
    lda [DX],y

    jsr OUT_PUT_DECIMAL_UBYTE_A                         ; A+ X+ Y- AL+ BX+

    lda # PETSCII_RETURN
    jsr KERNAL_CHROUT

    rts
.endproc

;;; summary: Change device number, if possible, showing error if not.
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;;   ARGV[1]: ZSTRING: Device number to change device
;;; out:
;;; changed:
;;;   A+ X+ Y+ AX+ BX+
.proc CHANGE_DEVICE
    ; A: UBYTE := ARGV[1].DECIMAL_TO_UBYTE              ; DEVICE
    lda # 1
    jsr GET_BX_GNUX_PARGV_INDEX_A
    jsr ZTRING_BX_DECIMAL_TO_UBYTE_A_USING_AL           ; A+ X- Y+ AL+ BX+
    if
        cmp # DEVICE_DISK_MIN
        bcc _then
        cmp # DEVICE_DISK_MAX + 1
        bcc _end
    then
        ldx # ERROR_NUMBER_WRONG_DEVICE
        jsr OUT_ERROR_X_NUMBER                          ; C = 1

        rts                                             ; FAIL
    else_end

    ; A = DEVICE
    pha
        jsr IS_DISK_DEVICE_PRESENT_A                    ; A+ X+ Y+ AX+
    pla
    if_cc_then
        ; Device is present
        ldy # 0
        sta [DX],y
    else_end

    rts
.endproc

;;; summary: Probe if disk device is present, showing error if not.
;;; in:
;;;   A: DEVICE
;;; changed: A+ X+ Y+ AX+
.proc IS_DISK_DEVICE_PRESENT_A
    tax
    jsr OPEN_DISK_COMMAND_STATUS_CHANNEL                ; in X=DEVICE | A+ X+ Y+ C+
    ; Open on non-existing device will not fail, so no need to check C here.
    ; Use CHKOUT to check if device is present; do not use CHKIN because this will hang when no device present.
    ldx # DISK_COMMAND_FA
    jsr KERNAL_CHKOUT                                   ; A- X- Y- C+
    php
        jsr CLOSE_DISK_COMMAND_STATUS_CHANNEL           ; in A+ X+ Y+ C+
        lda # DISK_COMMAND_FA
    plp
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr OUT_ERROR_X_NUMBER                          ; C=1
        rts                                             ; FAIL
    else_end

    ; C=0                                               ; OK

    rts
.endproc

;endregion

;region ZSTRING

;;; summary: Make AX empty ZSTRING on DISK_COMMAND_TEXT
;;; changed: A+ X- Y- AX+
.proc ZSTRING_AX_INIT_DISK_COMMAND_TEXT
    lda # < DISK_COMMAND_TEXT
    sta AL
    lda # > DISK_COMMAND_TEXT
    sta AH
    lda # PETSCII_NUL
    sta DISK_COMMAND_TEXT

    rts
.endproc

;;; summary: String length
;;; in:
;;;   AX: String, nul-terminated
;;; out:
;;;   Y: Length of string
;;; changed: A+ X- Y+
.proc ZSTRING_AX_LENGTH
    from
        ldy # 0
    loop
        lda [AX],y
        beq _end                                        ; break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: String length
;;; in:
;;;   BX: String, nul-terminated
;;; out:
;;;   Y: Length of string
;;; changed: A+ X- Y+
.proc ZSTRING_BX_LENGTH
    from
        ldy # 0
    loop
        lda [BX],y
        beq _end                                        ; break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Compare strings
;;; in:
;;;   AX: ZSTRING: Left
;;;   BX: ZSTRING: Right
;;; out:
;;;   Z: Is equal? 0 = no 1=yes
.proc ZSTRING_AX_COMPARE_ZSTRING_BX
    from
        ldy # 0
    loop
        lda [AX],y
        cmp [BX],y
        if_ne_then
            rts
        else_end
    next
        cmp # PETSCII_NUL
        beq _end
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Append char to string
;;; in:
;;;   A: BYTE: Source character
;;;   AX: ZSTRING: Target string
;;; changed: A+ X- Y+
.proc ZSTRING_AX_APPEND_CHAR_A
    pha
        from
            ldy # 0
        loop
            lda [AX],y
            beq _end                                    ; break
        next
            iny
            bne _loop                                   ; bra
        end
    pla
    sta [AX],y
    iny
    lda # PETSCII_NUL
    sta [AX],y

    rts
.endproc

.proc ZSTRING_AX_APPEND_ZSTRING_XY_USING_BX
    stx BL
    sty BH
    jsr ZSTRING_AX_APPEND_ZSTRING_BX

    rts
.endproc

;;; summary: Append string
;;; in:
;;;   AX: ZSTRING: Target
;;;   BX: ZSTRING: Source
;;; changed: A+ X- Y+
.proc ZSTRING_AX_APPEND_ZSTRING_BX
    lda CL
    pha
        lda CH
        pha
            from
                jsr ZSTRING_AX_LENGTH                   ; A+ X- Y+
                sty CH
                ldy # 0
                sty CL
            loop
                ldy CL
                lda [BX], y
                beq _end                                ; break
                ldy CH
                sta [AX],y
            next
                inc CL
                inc CH
                bne _loop                               ; bra
            end

            ; A = PETSCII_NUL
            ldy CH
            sta [AX],y
        pla
        sta CH
    pla
    sta CL

    rts
.endproc

;;; summary: Copy string
;;; in:
;;;   AX: TARGET
;;;   BX: SOURCE
;;; changed: A+ X- Y+
.proc ZSTRING_BX_COPY_TO_ZSTRING_AX
    from
        ldy # 0
    loop
        lda [BX], y
        sta [AX],y
        beq _end                                        ; break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;endregion

;region File

;;; summary: Open file
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: File Address
;;;   X: Device Address
;;;   Y: Secondary Address
;;; changed: A+ X+ Y+
;;; notes:
;;;   Open basically never fails, only the CHKIN/CHKOUT after it will fail if the device is not present.
.proc OPEN_FILE_AX
    jsr KERNAL_SETLFS                                   ; A=FA X=DA Y=SA | A- X- Y-
    jsr ZSTRING_AX_LENGTH                               ; A+ X- Y+
    tya
    ldx AL
    ldy AH
    jsr KERNAL_SETNAM                                   ; A=NAME.LENGTH X=<NAME Y=>NAME | A- X- Y-
    jsr KERNAL_OPEN                                     ; A+ X+ Y- C+

    rts
.endproc

;;; summary: Open file
;;; in:
;;;   BX: ZSTRING: File name
;;;   A: File Address
;;;   X: Device Address
;;;   Y: Secondary Address
;;; changed: A+ X+ Y+
;;; notes:
;;;   Open basically never fails, only the CHKIN/CHKOUT after it will fail if the device is not present.
.proc OPEN_FILE_BX
    jsr KERNAL_SETLFS                                   ; A=FA X=DA Y=SA | A- X- Y-
    jsr ZSTRING_BX_LENGTH                               ; A+ X- Y+
    tya
    ldx BL
    ldy BH
    jsr KERNAL_SETNAM                                   ; A=NAME.LENGTH X=<NAME Y=>NAME | A- X- Y-
    jsr KERNAL_OPEN                                     ; A+ X+ Y- C+

    rts
.endproc

;;; summary: Open file for input
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: File Address
;;;   X: Device Address
;;;   Y: Secondary Address
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ DFLTN=0 DFLTO=3
.proc OPEN_IN_FILE_AX
    pha
        lda GNUX_IN_FA
        if_ne_then
            ; Already open
            sec
        else_end
    pla
    pha
        jsr OPEN_FILE_AX                            ; A+ X+ Y+
    pla
    if_cc_then
        sta GNUX_IN_FA
    else_end

    rts
.endproc

;;; summary: Open file for input
;;; in:
;;;   BX: ZSTRING: File name
;;;   A: File Address
;;;   X: Device Address
;;;   Y: Secondary Address
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ DFLTN=0 DFLTO=3
.proc OPEN_IN_FILE_BX
    pha
        lda GNUX_IN_FA
        if_ne_then
            ; Already open
            sec
        else_end
    pla
    pha
        jsr OPEN_FILE_BX                                ; A+ X+ Y+ C+
    pla
    if_cc_then
        sta GNUX_IN_FA
    else_end

    rts
.endproc

;;; summary: Open file for output
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: File Address
;;;   X: Device Address
;;;   Y: Secondary Address
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ DFLTN=0 DFLTO=3
.proc OPEN_OUT_FILE_AX
    pha
        lda GNUX_OUT_FA
        if_ne_then
            ; Already open
            sec
        else_end
    pla
    pha
        jsr OPEN_FILE_AX                                ; A+ X+ Y+ C+
    pla
    if_cc_then
        sta GNUX_OUT_FA
    else_end

    rts
.endproc

;;; summary: Close file, handling redirection
;;; in:
;;;   A: FA
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+
.proc CLOSE
    cmp GNUX_IN_FA
    if_eq_then
        ldx # 0
        stx GNUX_IN_FA
    else_end

    cmp GNUX_OUT_FA
    if_eq_then
        ldx # 0
        stx GNUX_OUT_FA
    else_end

    jsr CLRCHN                                          ; A+ X+ Y- C1 DFLTN=0 DFLTO=3 STATUS=0

    jsr KERNAL_CLOSE                                    ; in A: FA | A+ X+ Y+ C+
    ; May fail on write buffered character

    rts
.endproc

;;; summary: Back to default file I/O
;;; changed: A+ X+ Y+
.proc RESET_FILE_IO
    jsr CLRCHN                                          ; A+ X+ Y- C=1 DFLTN=0 DFLTO=3 STATUS=0

    ; Close all open files
    from_loop
        ldx ZPKERNAL_LDTND
        beq _end
        lda KVAR_LAT
        jsr KERNAL_CLOSE                                ; A+ X+ Y+ C+
    next
        jmp _loop
    end

    ; Redirect input & output inactive
    lda # 0
    sta GNUX_IN_FA                                      ; 0 = Keyboard
    sta GNUX_OUT_FA                                     ; 0 = Screen

    rts
.endproc

;;; summary: Clear IN and OUT channel
;;; changed: A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0
;;; notes:
.proc CLRCHN
    pha
        txa
        pha
            jsr KERNAL_CLRCHN                           ; A+ X+ Y- C=1 DFLTN=0 DFLTO=3
            lda # 0
            ; Kernal `STATUS` may be non-zero, e.g. EOI, it is cleared on CHKIN/CHKOUT, but we do not CHKOUT before writing error because it is screen.
            sta ZPKERNAL_STATUS
        pla
        tax
    pla
    clc

    rts
.endproc

;;; summary: Select input channel
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A- X- Y- C+
.proc CHKIN
    clc
    pha
        txa
        pha
            jsr KERNAL_CHKIN                            ; A+ X+ Y- C+
        pla
        tax
    pla

    rts
.endproc

;;; summary: Select IN as input channel
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A- X- Y- C+
.proc IN_CHKIN
    clc
    pha
        txa
        pha
            ldx # 0
            stx ZPKERNAL_STATUS
            ldx GNUX_IN_FA
            if_ne_then
                jsr KERNAL_CHKIN                        ; A+ X+ Y- C+
            else_end
        pla
        tax
    pla

    rts
.endproc

;;; summary: Select output channel
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A- X- Y- C+
.proc CHKOUT
    clc
    pha
        txa
        pha
            jsr KERNAL_CHKOUT                           ; A+ X+ Y- C+
        pla
        tax
    pla


    rts
.endproc

;;; summary: Select OUT as output channel, with redirection.
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A- X- Y- C+
.proc OUT_CHKOUT
    pha
        txa
        pha
            ldx # 0
            stx ZPKERNAL_STATUS
            ldx GNUX_OUT_FA
            if_ne_then
                jsr KERNAL_CHKOUT                       ; A+ X+ Y- C+
            else_end
        pla
        tax
    pla

    rts
.endproc

;endregion

;region OUT

;;; summary: Write string to output channel (OUT), with error handling
;;; in:
;;;   AX: ZSTRING: String to write
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ N+ V+ Z+
.proc OUT_PUT_STRING_ZSTRING_AX
    from
        ldy # 0
    loop
        lda [AX],y
        beq _end                                        ; NUL -> break
        jsr KERNAL_CHROUT                               ; A+ X+ Y- C0 N+ V+ Z+
        ldx ZPKERNAL_STATUS
        bne _end                                        ; Error -> break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Write string to output channel (OUT), with error handling
;;; in:
;;;   AX: ZSTRING: String to write
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ N+ V+ Z+
.proc OUT_PUT_STRING_ZSTRING_BX
    from
        ldy # 0
    loop
        lda [BX],y
        beq _end                                        ; NUL -> break
        jsr KERNAL_CHROUT                               ; A+ X+ Y- C0 N+ V+ Z+
        ldx ZPKERNAL_STATUS
        bne _end                                        ; Error -> break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Write string to output channel (OUT)
;;; in:
;;;   X#Y: ZSTRING: String to write
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed:
;;;   A- X+ Y+ C+ N+ V+ Z+ AX+
.proc OUT_PUT_STRING_XY_USING_AX
    stx AL
    sty AH
    jsr OUT_PUT_STRING_ZSTRING_AX                       ; A+ X+ Y+ C+ N+ V+ Z+

    rts
.endproc

;;; summary: Write ZSTRING in AX, BX, CX
;;; in:
;;;   AX, BX, CX: ZSTRING: Source
;;; out:
;;;   C: 0: OK , 1: FAIL
;;; changed: A+ X+ Y+ C+ N+ V+ Z+
;;; notes:
;;;   Do not change DX
.proc OUT_PUT_ZSTRING_AX_BX_CX
    from
        ldy # 0
    loop
        ldx AX , y
        beq _end                                        ; NUL -> break
        txa
        jsr KERNAL_CHROUT                               ; A+ X+ Y- C0 N+ V+ Z+
        ldx ZPKERNAL_STATUS
        bne _end                                        ; Error -> break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;endregion

;region IN/OUT

;;; summary: Copy IN to OUT
;;; notes:
;;;   `<SHIFT>` pauses
;;;   `<STOP>` cancels. On cancel the channels are cleared.
;;;   What makes this routine a bit complicated is the fact that you get EOI on the last byte when calling `chrin`
;;;   So we still need to write that byte/char.
;;;   Basically, an empty file is not possible with CBM DOS, there are always at least 2 bytes.
.proc STREAM_COPY_IN_TO_OUT
    try
        lda # 0
        sta IN_STATUS
        sta OUT_STATUS

        from_loop COPY
            jsr CLRCHN                                  ; so second IN_CHKIN doesn't see device busy
            bit IN_STATUS
            bvs COPY::_end                              ; EOI -> break
            jsr IN_CHKIN                                ; A- X- Y- C+
            jsr KERNAL_CHRIN                            ; A+ X+ Y- C0 N+ V+ Z+
            tay
            jsr KERNAL_READST
            sta IN_STATUS
            ; bit 7: device not present: basically cannot happen anymore
            ; bit 6: end of input
            ; bit 1: timeout
            and # < ~ KERNAL_IO_EOI
            bne _catch                                  ; ERROR -> throw
            tya
            jsr OUT_CHKOUT                              ; A- X- Y- C+
            jsr KERNAL_CHROUT
            jsr KERNAL_READST
            sta OUT_STATUS
            bne _catch                                  ; ERROR -> throw

            ; STOP key pressed?
            jsr KERNAL_STOP                             ; A+ X- - C+ N+ V- Z+
            if_eq_then
                sec
                bcs COPY::_end                          ; Cancel -> break
            else_end

            jsr PAUSE_ON_SHIFT                          ; A+ X- Y-
        next
            jmp _loop
        end
    catch_finally_end

    rts
.endproc

;endregion

;region Conversion

;;; summary: Decimal string to unsigned byte
;;; in:
;;;   BX: ZSTRING: Decimal number string
;;; out:
;;;   A: UBYTE: Binary representation of input
;;; changed:
;;;   A+ X- Y+ AL+
;;; notes:
;;;   We do not check for valid input.
;;; cycles:
;;;   Depends on length of source:
;;;   1: 66
;;;   2: 113
;;;   3: 160
.proc ZTRING_BX_DECIMAL_TO_UBYTE_A_USING_AL
    from
        ldy # 0
        sty AL
    loop
        lda [BX],y
        beq _end                                        ; A = NUL -> break
        lda AL
        asl
        asl
        asl
        ; C=0
        adc AL
        adc AL
        sta AL
        lda [BX],y
        ; "0" = $30 <= A <= "9" = $39
        sec
        sbc # PETSCII_DIGIT_ZERO
        ; 0 <= A <= 9 ; C = 1
        clc
        adc AL
        sta AL
    next
        iny
        bne _loop                                       ; bra
    end

    lda AL

    rts
.endproc

;;; summary: Unsigned word (binary) to decimal string
;;; in:
;;;  AX: WORD: VALUE
;;; out:
;;;   BL,BH,CX: ZSTRING decimal representation of VALUE
;;; changed: A+ X+ Y+ AX+ BX+ CX+
;;; notes:
;;;   It uses a simple fixed loop that shifts the bits out of the binary value
;;;   one at a time and adds it to an intermediate result that is being doubled
;;;   (in BCD) on each iteration. Why? Because this is more efficient than the
;;;   traditional method of subtracting in a loop: this routine ~900 cycles
;;    v.s. up to 2000 cycles or more.
;;;   Source value is destroyed (becomes zero).
;;;   Disables interrupts because it uses Decimal mode.
;;;   Reference: book "6502 Instruction Set Guide" written by  Andrew John Jacobs and edited by Dion Olsthoorn, October 2021, chapter "Coding Algorithms", section "Decimal Arithmetic", pp. 27.
.proc AX_UWORD_TO_DECIMAL_AX_BX_CX
    ; Zero out result
    ldy # 0
    sty CL                                              ; LO
    sty BH                                              ; MED
    sty BL                                              ; HI
    ldx # 16                                            ; Bit counter
    sei
        sed
            from_loop
                asl AL
                rol AH
                lda CL
                adc CL
                sta CL
                lda BH
                adc BH
                sta BH
                lda BL
                adc BL
                sta BL
            next
                dex
                bne _loop
            end
        cld
    cli

    from_loop
        lda BX,x
        bne _end                                        ; A != 0 -> break
    next
        ; A=0
        inx
        cpx # 3
        bne _loop
    end

    ; X <= 3 ; Y=0
    ; (x = 3) = (A = 0)
    pha
        lsr
        lsr
        lsr
        lsr
        if_ne_then
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
        else_end
    pla
    and # $0F
    ora # PETSCII_DIGIT_ZERO
    sta AX,y
    iny
    cpx # 2
    if_lt_then
        inx
        from_loop
            lda BX,x
            lsr
            lsr
            lsr
            lsr
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
            lda BX,x
            and # $0F
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
        next
            inx
            cpx # 3
            bcc _loop
        end
    else_end

    lda # PETSCII_NUL
    sta AX,y

    rts
.endproc

;;; summary: Put unsigned byte to OUT as decimal
;;; in:
;;;  A: UBYTE: VALUE
;;; changed: A+ X+ Y- AL+ BX+
;;; notes:
;;;   No leading zeros.
;;;   This method is more efficient than the traditional subtract using
;;;   table of powers of 10 method.
.proc OUT_PUT_DECIMAL_UBYTE_A
    sta AL
    ; Zero out result
    ldx # 0
    stx BL                                              ; HI
    stx BH                                              ; LO
    ldx # 8                                             ; Bit counter
    sei                                                 ; Because IRQ/NMI handlers use (or may use) adc/sbc
        sed
            from_loop
                asl AL
                lda BH
                adc BH
                sta BH
                lda BL
                adc BL
                sta BL
            next
                dex
                bne _loop
            end
        cld
    cli

    from_loop
        lda BX,x
        bne _end                                        ; A != 0 -> break
    next
        ; A=0
        inx
        cpx # 2
        bne _loop
    end

    try
        ; X <= 2 ; Y=0
        ; (x = 2) = (A = 0)
        pha
            lsr
            lsr
            lsr
            lsr
            if_ne_then
                ora # PETSCII_DIGIT_ZERO
                jsr KERNAL_CHROUT                       ; A- X- Y- C0 N+ V+ Z+
                lda ZPKERNAL_STATUS
                bne _catch
            else_end
        pla
        and # $0F
        ora # PETSCII_DIGIT_ZERO
        jsr KERNAL_CHROUT                       ; A- X- Y- C0 N+ V+ Z+
        lda ZPKERNAL_STATUS
        bne _catch

        cpx # 1
        if_lt_then
            inx
            from_loop
                lda BX,x
                lsr
                lsr
                lsr
                lsr
                ora # PETSCII_DIGIT_ZERO
                jsr KERNAL_CHROUT                       ; A- X- Y- C0 N+ V+ Z+
                lda ZPKERNAL_STATUS
                bne _catch
                lda BX,x
                and # $0F
                ora # PETSCII_DIGIT_ZERO
                jsr KERNAL_CHROUT                       ; A- X- Y- C0 N+ V+ Z+
                lda ZPKERNAL_STATUS
                bne _catch
            next
                inx
                cpx # 2
                bcc _loop
            end
        else_end
    catch_finally_end

    rts
.endproc

;endregion

;region Branch to subroutine

;;; summary Jump to subroutine indirect
;;; in:
;;;   DX: Address of souroutine
.proc JSR_INDIRECT_DX
    jmp [DX]
.endproc

;endregion

;region Keyboard

;;; summary: Pause on SHIFT
.proc PAUSE_ON_SHIFT
    from_loop
        lda ZPKERNAL_SFDX
            ; $CB Matrix code of key currently being pressed. Values: 
            ; $00-$3F: Keyboard matrix code
            ; $40: No key is currently pressed
        eor # $40
        ora KVAR_SHFLAG
        ; $028D Shift key indicator. Bits:
        ; Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked.
        ; Bit #1: 1 = Commodore is currently being pressed.
        ; Bit #2: 1 = Control is currently being pressed.
    next
        bne _loop
    end

    rts
.endproc

;endregion

;region Error handling

;;;   X: Error number
;;; out:
;;;   C=1
;;; changed: A+ AX+
.proc OUT_ERROR_X_NUMBER
    lda TABLE_ERROR_MESSAGE_LO,x
    sta AL
    lda TABLE_ERROR_MESSAGE_HI,x
    sta AH

    ; IN = KEYBOARD , OUT = SCREEN
    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0

    jsr OUT_PUT_STRING_ZSTRING_AX
    lda # PETSCII_RETURN
    jsr KERNAL_CHROUT                                   ; A- X- Y- C0

    sec                                                 ; FAIL

    rts
.endproc

;endregion

;region NMI handler

;;; summary: My NMI handler.
;;; notes:
;;;   We catch <RUN STOP> + <RESTORE> else we go back to BASIC.
.proc MY_NMI_HANDLER
    ; check I = 1

    ; Check for and prevent re-entry
    bit NMI_ENTRY_COUNT
    if_mi_then
        ; Already in an NMI call (not sure how this could happen, maybe on bouncing RESTORE key)
        rti
    else_end

    ; First entry
    pha
    txa
    pha
        tya
        pha
            ; Disable all CIA-2 interrupts (why?)
            lda # $7F
            sta CIA_2_ICR
            ; Process any pending CIA-2 interrupt.
            ; NMI occured?
            ldy CIA_2_ICR
            if_mi_then
                ; NMI occured yes
                jmp KERNAL_NNMI20                   ; Continue at original Kernal NMI handler
            else_end

            ; NMI occured no
            ; RESTORE key was pressed
            ; STOP key pressed? Z=1 (eq): yes, Z=0 (ne): no
            jsr KERNAL_STOP
            if_ne_then
                ; STOP key was not pressed
                jmp KERNAL_NNMI20                   ; Continue at original Kernal NMI handler
            else_end

            ; STOP key was pressed

            dec NMI_ENTRY_COUNT                         ; FALSE -> TRUE: prevent re-entry

            ; Set text screen base to default (in case it got changed).
            lda # >SCREEN_TEXT_RAM_BASE
            sta KVAR_HIBASE

            ; Save and restore colors because called Kernal routine changes them.
            lda KVAR_COLOR
            pha
                lda VIC_EC
                pha
                    lda VIC_B0C
                    pha
                        jsr KERNAL_IOINIT
                        ; Kernal ioinit:
                        ; Also sets memory configuration to default: BASIC ROM, IO DEVICES, KERNAL ROM, Datasette output off motor off
                        jsr KERNAL_CINT
                        ; Kernal cint:
                        ; Also sets default I/O: output dflto := 3 (screen), input dfltn := 0 (keyboard)
                    pla
                    sta VIC_B0C
                pla
                sta VIC_EC
            pla
            sta KVAR_COLOR

            ; Restore stack pointer to where it was on NMI.
            ldx SAVE_S
            txs

            ; Enable interrupts so we can do file I/O.
            cli

            inc NMI_ENTRY_COUNT                     ; TRUE -> FALSE: allow entry
            jmp RUN                                 ; Resume
.endproc

;endregion

;region Maps

;;; summary: Map command name to number
;;; in:
;;;   BX: ZSTRING: Candidate command
;;; out:
;;;   X: Command number, if Z=1
;;;   Z: 1 = found , 0 = not found
;;; changed: A+ X- Y+ AX+
.proc MAP_COMMAND_NAME_TO_COMMAND_NUMBER
    from
        ldx # TABLE_COMMAND_NAME_SIZE - 1
    loop
        lda TABLE_COMMAND_NAME_LO, x
        sta AL
        lda TABLE_COMMAND_NAME_HI, x
        sta AH
        jsr ZSTRING_AX_COMPARE_ZSTRING_BX               ; A+ X- Y+ Z+
        beq _end                                        ; Z=1 -> equal -> break
    next
        dex
        bpl _loop
        ; N=1 Z=0 -> Exhausted
    end

    rts
.endproc

;endregion
