;    sh: Shell for Commodore 64.
;    Copyright (C) 2026 C64PECTRE
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see https://www.gnu.org/licenses/.
;
;    Contact: https://github.com/c64pectre/exehdr/ create an issue

;region Kernal internal

KERNAL_NNMI20 := $FE72                                  ; Kernal nnmi20 continuation of NMI handing.

;endregion

;region Memory areas

; Area 1: $0200-$0258 89 bytes Command line
AREA_1       := KVAR_BUF_BUFOFS
AREA_1_LAST  := KVAR_BUF_BUFOFS_LAST
AREA_1_SIZE  =  KVAR_BUF_BUFOFS_SIZE

; Area 2: $02A7-$02FF 89 bytes
AREA_2      := KVAR_UNUSED_1
AREA_2_LAST := KVAR_UNUSED_1_LAST
AREA_2_SIZE =  KVAR_UNUSED_1_SIZE

; Area 3: $0334-$033B 8 bytes - ABI
AREA_3      := KVAR_UNUSED_2
AREA_3_LAST := KVAR_UNUSED_2_LAST
AREA_3_SIZE =  KVAR_UNUSED_2_SIZE

; Area 4: $033C-$03FF 196 bytes
AREA_4      := KERNAL_TBUFFR
AREA_4_LAST := KVAR_UNUSED_3_LAST
AREA_4_SIZE =  AREA_4_LAST - AREA_4 + 1

;endregion

;region Memory layout

; Begin of ABI (Application Binary Interface)

; see the-abi-export.asm

; end of ABI

;;; Command line
COMMAND_LINE      := AREA_1
COMMAND_LINE_SIZE =  82
        .assert COMMAND_LINE_SIZE <= AREA_1_SIZE , error
COMMAND_LINE_LAST := COMMAND_LINE + COMMAND_LINE_SIZE

ARGV      := AREA_4 + 4                                 ; $0340 ; AREA_4 + 4
ARGV_0    := ARGV + 0                                   ; $0340 ; AREA_4 + 4
ARGV_0_LO := ARGV_0                                     ; $0340 ; AREA_4 + 4
ARGV_0_HI := ARGV_0 + 1                                 ; $0341 ; AREA_4 + 5
ARGV_1    := ARGV + 2                                   ; $0342 ; AREA_4 + 6
ARGV_1_LO := ARGV_1                                     ; $0342 ; AREA_4 + 6
ARGV_1_HI := ARGV_1 + 1                                 ; $0343 ; AREA_4 + 7
ARGV_2    := ARGV + 4                                   ; $0344 ; AREA_4 + 8
ARGV_2_LO := ARGV_2                                     ; $0344 ; AREA_4 + 8
ARGV_2_HI := ARGV_2 + 1                                 ; $0345 ; AREA_4 + 9
ARGV_3    := ARGV + 6                                   ; $0346 ; AREA_4 + 10
ARGV_3_LO := ARGV_3                                     ; $0346 ; AREA_4 + 10
ARGV_3_HI := ARGV_3 + 1                                 ; $0347 ; AREA_4 + 11
ARGV_4    := ARGV + 8                                   ; $0348 ; AREA_4 + 12
ARGV_4_LO := ARGV_4                                     ; $0348 ; AREA_4 + 12
ARGV_4_HI := ARGV_4 + 1                                 ; $0349 ; AREA_4 + 13
ARGV_5    := ARGV + 10                                  ; $034A ; AREA_4 + 14
ARGV_5_LO := ARGV_5                                     ; $034A ; AREA_4 + 14
ARGV_5_HI := ARGV_5 + 1                                 ; $034B ; AREA_4 + 15
ARGV_6    := ARGV + 12                                  ; $034C ; AREA_4 + 16
ARGV_6_LO := ARGV_6                                     ; $034C ; AREA_4 + 16
ARGV_6_HI := ARGV_6 + 1                                 ; $034D ; AREA_4 + 17
ARGV_7    := ARGV + 14                                  ; $034E ; AREA_4 + 18
ARGV_7_LO := ARGV_7                                     ; $034E ; AREA_4 + 18
ARGV_7_HI := ARGV_7 + 1                                 ; $034F ; AREA_4 + 19
ARGV_8    := ARGV + 16                                  ; $0350 ; AREA_4 + 20
ARGV_8_LO := ARGV_8                                     ; $0350 ; AREA_4 + 20
ARGV_8_HI := ARGV_8 + 1                                 ; $0351 ; AREA_4 + 21
ARGV_9    := ARGV + 18                                  ; $0352 ; AREA_4 + 22
ARGV_9_LO := ARGV_9                                     ; $0352 ; AREA_4 + 22
ARGV_9_HI := ARGV_9 + 1                                 ; $0353 ; AREA_4 + 23

; String buffer for disk command, directory, file. Need 40 bytes + 1 for NUL.
DISK_COMMAND_LENGTH = 41
DISK_COMMAND_TEXT               := AREA_4 + 24 + 19

; Disk status Max is 35 bytes
DISK_STATUS_LENGTH = 35
DISK_STATUS_TEXT                := AREA_4 + 24 + 19 + 41
DISK_STATUS_TEXT_CODE_0         := DISK_STATUS_TEXT + 0
DISK_STATUS_TEXT_CODE_1         := DISK_STATUS_TEXT + 1

;;; summary: Name of loaded program, if any (then LOADED_COMMAND_NAME[0] != 0) $03A6-$03B4 (14 bytes)
LOADED_COMMAND_NAME             := AREA_4 + 24 + 19 + 41 + 35
LOADED_COMMAND_NAME_SIZE        = FILE_NAME_MAX_LENGTH + 1

; Save colors
SAVE_KVAR_COLOR                 := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1
SAVE_VIC_EC                     := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 1
SAVE_VIC_B0C                    := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 2
; NMI
SAVE_KERNAL_NMINV_LO            := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 3
SAVE_KERNAL_NMINV_HI            := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 4
SAVE_S                          := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 5
NMI_ENTRY_COUNT                 := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 6
; IN/OUT
IN_STATUS                       := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 7
OUT_STATUS                      := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 8

LOAD_COMMAND_NAME               := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 9
LOAD_COMMAND_NAME_LO            := LOAD_COMMAND_NAME + 0
LOAD_COMMAND_NAME_HI            := LOAD_COMMAND_NAME + 1

; FOR_EACH_ARGC
FOR_EACH_ARG_LAMBDA             := AREA_4 + 24 + 19 + 41 + 35 + FILE_NAME_MAX_LENGTH + 1 + 11
FOR_EACH_ARG_LAMBDA_LO          := FOR_EACH_ARG_LAMBDA
FOR_EACH_ARG_LAMBDA_HI          := FOR_EACH_ARG_LAMBDA + 1

;endregion

;region Main

;;; summary: Main
.proc MAIN
    jsr INITIALIZE
    jsr RUN

    rts
.endproc

;endregion

;region Loop

;;; summary: Initialize
.proc INITIALIZE
    ; Save stack pointer
    tsx
    stx SAVE_S

    ldx # REGISTER_STACK
    stx z:RP
    stx z:FP

    ; Set border color
    lda CONFIG_BORDER_COLOR
    if_pl_then
        sta VIC_EC
    else_end

    ; Set background color
    lda CONFIG_BACKGROUND_COLOR
    if_pl_then
        sta VIC_B0C
    else_end

    ; Set foreground color
    lda CONFIG_FOREGROUND_COLOR_CHAR
    if_ne_then
        jsr KERNAL_CHROUT
    else_end

    ; Clear screen
    lda # PETSCII_CLR
    jsr KERNAL_CHROUT

    ; Set system and work device to default device (8)
    lda # DEFAULT_DEVICE
    sta GNUX_SYS_DEVICE
    sta GNUX_WORK_DEVICE

    ; Set system and work device to device number of current file, if any.
    lda z:ZPKERNAL_FA
    if_ne_then
        sta GNUX_SYS_DEVICE
        sta GNUX_WORK_DEVICE
    else_end

    ; GNUX_PARGV = &ARGV
    lda # < ARGV
    sta GNUX_PARGV_LO
    lda # > ARGV
    sta GNUX_PARGV_HI

    lda # 0                                             ; A = 0 = FALSE = PETSCVII_NUL

    ; GNUX_ARGC = 0. Note: GNUX_ARGC_HI is always 0 because GNUX_ARGC_MAX = 10
    sta GNUX_ARGC_LO
    sta GNUX_ARGC_HI

    ; Reset NMI entry count
    sta NMI_ENTRY_COUNT

    ; Redirect input & output inactive
    sta GNUX_IN_LA                                      ; 0 = Keyboard
    sta GNUX_OUT_LA                                     ; 0 = Screen

    ; Set no program loaded
    sta LOADED_COMMAND_NAME

    ; Save NMI handler
    lda KERNAL_NMINV_LO
    sta SAVE_KERNAL_NMINV_LO
    lda KERNAL_NMINV_HI
    sta SAVE_KERNAL_NMINV_HI

    ; Set our NMI handler
    lda # <MY_NMI_HANDLER
    sta KERNAL_NMINV_LO
    lda # >MY_NMI_HANDLER
    sta KERNAL_NMINV_HI

    rts
.endproc

;;; summary: Run loop
.proc RUN
    from_loop
        jsr RESET_FILE_IO

        lda # PETSCII_SHIFTED_MODE
        jsr KERNAL_CHROUT

        jsr SHOW_PROMPT
        jsr READ_COMMAND_LINE
        jsr PROCESS_COMMAND_LINE
    next
        jmp _loop
    end

    ; Does not come here
.endproc

;;; summary: Show prompt
;;; changed: A+ X- Y+ AX+
.proc SHOW_PROMPT
    ldx # < RESOURCE_ZSTRING_PROMPT
    ldY # > RESOURCE_ZSTRING_PROMPT
    jsr PUT_ZSTRING_XY                                  ; BX+

    rts
.endproc

;;; summary: Read line from input (presumably keyboard)
;;; out:
;;;   COMMAND_LINE: One line of text, return replaced with nul.
;;; changed: A+ X+ Y+
.proc READ_COMMAND_LINE
    from
        ldy # 0
    loop
        jsr KERNAL_CHRIN                                ; A+ X+ Y- C+
        sta COMMAND_LINE , y 
        cmp # PETSCII_RETURN
        beq _end
    next
        iny
        bne _loop
    end

    jsr KERNAL_CHROUT                                   ; A- X- Y- C=0

    ; Replace RETURN with NUL
    lda # PETSCII_NUL
    sta COMMAND_LINE , y

    rts
.endproc

;endregion

;region Parsing

;;; summary: Process input text
;;; in:
;;;   COMMAND_LINE: Input text, nul terminated
;;; changed: A+ X+ Y+ AX+ CX+ BX+ DX+
;;; notes:
;;;   A command line is a series of argument values, separated by one or
;;;   more SPACE or NO_BREAK_SPACE; an argument may be deliniated by
;;;   quotation marks. Input redirection indicator is '<'. Output
;;;   redirection to a file indicator is '>'. Output redirection to the
;;;   printer is '>>'. Redirection file names can be quoted too.
;;;   We only need to inc DL (and not DH as well) because we will not cross the page.
.proc PROCESS_COMMAND_LINE
    jsr PARSE_COMMAND_LINE
    ; Have we got any arguments?
    lda GNUX_ARGC_LO
    if_ne_then
        ; We have got arguments?
        ; AX: ZSTRING := ARGV[0] = COMMAND
        lda # 0
        jsr GET_AX_ARGV_A                               ; A+ X- Y+ AX+
        ldy # 0
        lda [AX],y
        ; Argument 0 not empty?
        if_ne_then
            try
                ldx GNUX_WORK_DEVICE
                jsr OPEN_DISK_COMMAND_CHANNEL
                bcs _catch
                jsr TRY_BUILT_IN_COMMAND
                if_cs_then                              ; Not built-in command
                    jsr LOAD_COMMAND_IF_NOT_ALREADY_LOADED
                    if_cc_then
                        jsr EXECUTE_COMMAND
                    else_end
                else_end
            catch_finally
                jsr CLOSE_DISK_COMMAND_CHANNEL
            end
        else_end
    else_end

    rts
.endproc

;;; summary: Parse command line
.proc PARSE_COMMAND_LINE
    ; GNUX_ARGC := 0
    ldy # 0
    sty GNUX_ARGC_LO
    ; GNUX_ARGC_HI is always 0

    from ITERATE_COMMAND_LINE
        ; POINTER TO BYTE DX := & COMMAND_LINE
        lda # < COMMAND_LINE
        sta z:DL
        lda # > COMMAND_LINE
        sta z:DH
    loop
        ; check Y = 0
        jsr SKIP_BLANKS                                 ; A+ X- Y-
        cmp # PETSCII_NUL
        beq ITERATE_COMMAND_LINE::_end                  ; NUL -> break

        ; Redirect input from file?
        cmp # PETSCII_LESS_THAN_SIGN
        if_eq_then
            ; Yes
            ; Skip '<'
            inc z:DL
            jsr REDIRECT_INPUT_FROM_FILE                ; A+ X+ Y+ AX+ BX+
            ldy # 0
            bcc ITERATE_COMMAND_LINE::_loop             ; OK -> continue

            ; Error redirecting input from file
            ldx # ERROR_NUMBER_CANT_OPEN_INPUT_FILE
            jsr PUT_ERROR_X_NUMBER

            rts
        else_end

        ; Redirect output to file or printer?
        cmp # PETSCII_GREATER_THAN_SIGN
        if_eq_then
            ; Skip '>'
            inc z:DL
            ; check Y = 0
            lda [DX],y
            cmp # PETSCII_GREATER_THAN_SIGN
            if_eq_then
                ; Skip second '>'
                inc z:DL
                ; Redirect output to printer
                jsr REDIRECT_OUTPUT_TO_PRINTER          ; A+ X+ Y+ C+
                ldy # 0
                bcc ITERATE_COMMAND_LINE::_loop         ; OK -> continue

                ; Error redirecting output to printer
                ldx # ERROR_NUMBER_PRINTER_NOT_PRESENT
                jsr PUT_ERROR_X_NUMBER

                rts
            else_end

            ; Redirect output to file
            jsr REDIRECT_OUTPUT_TO_FILE                 ; A+ X+ Y+ AX+ BX+ CX+ DX+
            ldy # 0
            bcc ITERATE_COMMAND_LINE::_loop             ; OK -> continue

            ; Error redirecting output to file
            ldx # ERROR_NUMBER_CANT_OPEN_OUTPUT_FILE
            jsr PUT_ERROR_X_NUMBER

            rts
        else_end

        ; We have the start of an argument.
        ; check A = [DX]
        ; check A != NUL and A != SPACE and A != NO_BREAK_SPACE
        ; Quotation mark?
        pha
            cmp # PETSCII_QUOTATION_MARK
            if_eq_then
                inc z:DL
            else_end

            jsr SET_ARGV                                ; A+ X- Y=0
        pla
        cmp # PETSCII_QUOTATION_MARK
        if_eq_then
            jsr SKIP_QUOTED                             ; A+ X- Y- Z=1 DL+
            beq _end                                    ; bra
        else
            jsr SKIP_UNQUOTED                           ; A+ X- Y- Z=1 DL+
        end

        ; check A = [DX]
        cmp # PETSCII_NUL
        beq ITERATE_COMMAND_LINE::_end                  ; NUL -> EOI -> break break

        ; A != NUL and (A = SPACE or A = NO_BREAK_SPACE or A = QUOTATION_MARK)
        lda # PETSCII_NUL
        ; check Y = 0
        sta [DX],y
        inc z:DL
    next
        bne ITERATE_COMMAND_LINE::_loop                 ; bra
    end

    rts
.endproc


;;; summary: AX := ARGV[A]
;;; in:
;;;   A: Index 
;;; out:
;;;  AX: GNUX_PARGV[A]
;;; changed: A+ X- Y+ BX+
.proc GET_AX_ARGV_A
    ; AX := GNUX_PARGV[A]
    ldy GNUX_PARGV_LO
    sty z:AL
    ldy GNUX_PARGV_HI
    sty z:AH
    asl
    tay
    lda [AX],y
    tax
    iny
    lda [AX],y
    sta z:AH
    stx z:AL

    rts
.endproc

;;; summary: Skip SPACE and NO_BREAK_SPACE in command line
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   DX: Pointer advanced to non blank character (may be NUL)
;;;   Z: 1: *DX = NUL , 0: *DX != NUL
;;; changed: A+ X- Y- DL+
.proc SKIP_BLANKS
    ; check Y = 0
    from_loop
        ; A := [DX]
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_SPACE
        if_eq_then
            inc z:DL
            bne _loop                                   ; SPACE -> continue
        else_end

        cmp # PETSCII_NO_BREAK_SPACE
        if_eq_then
            inc z:DL
            bne _loop                                   ; NO_BREAK_SPACE -> continue
        else_end
    next_end

    rts
.endproc

;;; summary: Skip up to and including NUL, SPACE, NO_BREAK_SPACE.
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   A: = [DX]
;;;   A: = NUL or = SPACE or = NO_BREAK_SPACE
;;;;  Z: = 1
;;; changed: A+ X- Y- DL+
.proc SKIP_UNQUOTED
    ; check Y = 0
    from_loop
        ; A := [DX]
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_SPACE
        beq _end                                        ; SPACE -> break

        cmp # PETSCII_NO_BREAK_SPACE
        beq _end                                        ; NO_BREAK_SPACE -> break
    next
        inc z:DL
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Skip up to and including NUL, QUOTATION_MARK.
;;; in:
;;;   DX: Pointer in command line
;;; out:
;;;   A: = NUL or = QUOTATION_MARK
;;;   Z: = 1
;;;   [DX]: = NUL or = QUOTATION_MARK
;;; changed: A+ X- Y- DL+
.proc SKIP_QUOTED
    ; check Y = 0
    from_loop
        ; A := *DX
        lda [DX],y
        beq _end                                        ; EOI -> break
    
        cmp # PETSCII_QUOTATION_MARK
        beq _end                                        ; QUOTATION_MARK -> break
    next
        inc z:DL
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Set ARGV index GNUX_ARGC to pointer in input text
;;; in:
;;;   GNUX_ARGC: Argument count
;;;   DX: POINTER TO BYTE: Pointer in command line to start of argument text
;;; out:
;;;   Y: = 0
;;;   ARGV[GNUX_ARGC++]: = DX
;;; changed:
;;;   A+ X- Y=0
.proc SET_ARGV
    ; Y := GNUX_ARGC * SIZEOF(WORD) = GNUX_ARGC * 2 = GNUX_ARGC << 1
    lda GNUX_ARGC_LO
    asl
    tay
    ; POINTER TO WORD (ARGV + Y) := DX
    lda z:DL
    sta ARGV,y
    lda z:DH
    sta ARGV + 1,y
    inc GNUX_ARGC_LO

    ldy # 0

    rts
.endproc

;;; summary: Get (extract) file name from `COMMAND_LINE` from position `DX`.
;;; in:
;;;   BYTE[] DX=POINTER_COMMAND_LINE  Pointer in command line, initially to the '>'. Advanced to after file name.
;;; out:
;;;   AX: ZSTRING: DISK_COMMAND_TEXT: file name unquoted. May be empty.
;;; changed: A+ X- Y+ AX+ BX+ DL+
.proc GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE
    ; check Y = 0
    ; [DX] != NUL and [DX] != PETSCII_SPACE and [DX] != PETSCII_NO_BREAK_SPACE and [DX] != PETSCII_PETSCII_LESS_THAN_SIGN and [DX] != PETSCII_PETSCII_GREATER_THAN_SIGN

    ; AX := ZSTRING.NEW(DISK_COMMAND_TEXT)
    jsr ZSTRING_AX_NEW_DISK_COMMAND_TEXT                ; A+ X- Y- AX+

    ; Skip blanks
    jsr SKIP_BLANKS                                     ; A+ X- Y=0 DL+
    cmp # PETSCII_NUL
    if_eq_then
        ; Empty string
        sec                                             ; FAIL
        rts
    else_end

    ; A = [POINTER_COMMAND_LINE]

    ; check Y = 0
    ; check A != NUL and A != SPACE and A != NO_BREAK_SPACE
    ; A is quotation mark or not
    pha
        cmp # PETSCII_QUOTATION_MARK
        if_eq_then
            inc z:DL
        else_end

        ; ZSTRING BX=FILE_NAME := POINTER_COMMAND_LINE
        lda z:DL
        sta z:BL
        lda z:DH
        sta z:BH
    pla
    cmp # PETSCII_QUOTATION_MARK
    if_eq_then
        jsr SKIP_QUOTED                                 ; A+ X- Y- Z1 DL+
        beq _end                                        ; bra
    else
        jsr SKIP_UNQUOTED                               ; A+ X- Y- Z+ DL+
    end

    cmp # PETSCII_NUL
    if_ne_then
        ; A = SPACE or A = NO_BREAK_SPACE or A = QUOTATION_MARK
        lda # PETSCII_NUL
        sta [DX],y
        inc z:DL
    else_end
 
    jsr ZSTRING_AX_COPY_FROM_ZSTRING_BX                 ; A+ X- Y+

    clc                                                 ; OK

    rts
.endproc

;endregion

;region Redirection

;;; summary: redirect input from file named `FILE_NAME_TEXT` extracted from `COMMAND_LINE` on work disk
;;; in:
;;;   COMMAND_LINE: Command line text
;;;   DX: pointer in COMMAND_LINE
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ AX+ BX+
.proc REDIRECT_INPUT_FROM_FILE
    ; check Y = 0
    lda GNUX_IN_LA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    jsr GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE      ; A+ X- Y+ AX+ BX+ DX+
    if_cc_then
        lda # REDIRECT_INPUT_LA
        ldx GNUX_WORK_DEVICE
        ldy # REDIRECT_INPUT_SA
        jsr OPEN_IN_FILE_AX                             ; A+ X+ Y+ C+
    else_end

    rts
.endproc

;;; summary: Redirect output to file named `FILE_NAME_TEXT` extracted from `COMMAND_LINE` on work disk
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DX+
;;; notes:
;;;   Do not use DX
.proc REDIRECT_OUTPUT_TO_FILE
    ; check Y = 0
    lda GNUX_OUT_LA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    ; AX=FILE_NAME := ZSTRING.NEW(DISK_COMMAND_TEXT)
    jsr GET_ZSTRING_AX_FILE_NAME_FROM_COMMAND_LINE      ; A+ X- Y+ AX+ BX+ DX+
    if_cc_then
        ; + ",s,w"
        ldx # < RESOURCE_ZSTRING_SEQ_WRITE
        ldy # > RESOURCE_ZSTRING_SEQ_WRITE
        jsr ZSTRING_AX_APPEND_ZSTRING_XY                ; A+ X- Y+ BX+ CX+
        ; Open
        lda # REDIRECT_OUTPUT_LA
        ldx GNUX_WORK_DEVICE
        ldy # REDIRECT_OUTPUT_FILE_SA
        jsr OPEN_OUT_FILE_AX                            ; A+ X+ Y+ C+ BL+
    else_end

    rts
.endproc

;;; summary: Redirect output to printer (device 4, secondary address 7 is upper and lower case charecters)
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ AX+
.proc REDIRECT_OUTPUT_TO_PRINTER
    lda GNUX_OUT_LA
    if_ne_then
        sec                                             ; FAIL
        rts
    else_end

    ; check GNUX_OUT_LA = 0

    ; Open with no name
    lda # < RESOURCE_STRING_EMPTY
    sta z:AL
    lda # > RESOURCE_STRING_EMPTY
    sta z:AH
    lda # REDIRECT_OUTPUT_LA
    ldx # REDIRECT_OUTPUT_PRINTER_DA
    ldy # REDIRECT_OUTPUT_PRINTER_SA
    jsr OPEN_OUT_FILE_AX                                ; A+ X+ Y+ C+ BL+

    rts
.endproc

;endregion

;region Execution

;;; summary: Try built-in command
;;; in:
;;;   AX: ZSTRING: Candidate command
;;; changed: A+ X+ Y+ BX+ DX+
.proc TRY_BUILT_IN_COMMAND
    jsr MAP_AX_COMMAND_NAME_TO_COMMAND_NUMBER           ; X = command number if Z=1
    if_ne_then
        sec                                             ; Not built-in command
        rts
    else_end

    lda TABLE_COMMAND_HANDLER_LO,x
    sta z:DL
    lda TABLE_COMMAND_HANDLER_HI,x
    sta z:DH

    jsr JSR_INDIRECT_DX

    clc                                                 ; OK

    rts
.endproc

;;; summary: Execute loaded program
;;; notes:
;;;   Entry point is at $1800
;;; changed: A+ X+ Y+ AX+ RP+ FP+
.proc EXECUTE_COMMAND
    try
        ; Save colors
        lda KVAR_COLOR
        sta SAVE_KVAR_COLOR
            lda VIC_EC
            sta SAVE_VIC_EC
                lda VIC_B0C
                sta SAVE_VIC_B0C
                    ; Call program's entrypoint, passing GNUX_ARGC and ARGV arguments.
                    ldx # REGISTER_STACK
                    lda GNUX_ARGC_LO
                    sta z:0,x
                    inx
                    lda GNUX_ARGC_HI
                    sta z:0,x
                    inx
                    lda GNUX_PARGV_LO
                    sta z:0,x
                    inx
                    lda GNUX_ARGC_HI
                    sta z:0,x
                    inx
                    stx z:RP
                    stx z:FP
                    ; Execute command/ run program
                    jsr PROGRAM_ENTRYPOINT
                lda SAVE_VIC_B0C
                sta VIC_B0C
            lda SAVE_VIC_EC
            sta VIC_EC
        lda SAVE_KVAR_COLOR
        sta KVAR_COLOR
        jsr FILL_COLOR_SCREEN_A
    catch_finally_end

    rts
.endproc

;;; summary: Fill color screen
;;; in:
;;;   A: BYTE: Color
;;; changed:
;;;   A- X+ Y-
.proc FILL_COLOR_SCREEN_A
    from
        ldx # 250
    loop
        sta SCREEN_COLOR_RAM_BASE       - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 250 - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 500 - 1 , x
        sta SCREEN_COLOR_RAM_BASE + 750 - 1 , x
    next
        dex
        bne _loop
    end

    rts
.endproc

;endregion

;region Loading

;;; summary: Load program with, if not already done so.
;;; in:
;;;   AX: Name of program to load.
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ AX+ BX+ DL+ LOAD_COMMAND_NAME+
.proc LOAD_COMMAND_IF_NOT_ALREADY_LOADED
    ; Already loaded?
    lda # < LOADED_COMMAND_NAME
    sta z:BL
    lda # > LOADED_COMMAND_NAME
    sta z:BH
    jsr ZSTRING_AX_COMPARE_ZSTRING_BX                   ; A+ X- Y+ Z+
    if_eq_then
        clc                                             ; OK
        rts
    else_end

    jsr LOAD_COMMAND_FROM_WORK_OR_SYS_DISK              ; A+ X+ Y+ C+ AX+ BX+ DL+ LOAD_COMMAND_NAME+

    rts
.endproc

;;; summary: Load program from work disk or else from system disk
;;; in:
;;;   AX: ZSTRING: Name of program to load.
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ AX+ BX+ DL+ LOAD_COMMAND_NAME+
.proc LOAD_COMMAND_FROM_WORK_OR_SYS_DISK
    lda z:AL
    sta LOAD_COMMAND_NAME_LO
    lda z:AH
    sta LOAD_COMMAND_NAME_HI

    ; Try work disk
    ldx GNUX_WORK_DEVICE
    jsr LOAD_COMMAND ; AX+
    if_cs_then
        ; Load from work disk failed.
        ; Try system disk
        ldx GNUX_SYS_DEVICE
        jsr LOAD_COMMAND                                ; A+ X+ Y+ C+ AX+ BX+ DL+
        if_cs_then
            ; Load from system disk failed too.
            ; X = ERROR_NUMBER_*
            jsr PUT_ERROR_X_NUMBER

            rts
        else_end
    else_end

    ; Save name of loaded program.
    ; notes: We know program name is max 16 characters + 1 for NUL
    lda # < LOADED_COMMAND_NAME
    sta z:AL
    lda # > LOADED_COMMAND_NAME
    sta z:AH
    ldx # < LOAD_COMMAND_NAME_LO
    ldy # > LOAD_COMMAND_NAME_HI
    jsr ZSTRING_AX_COPY_FROM_ZSTRING_XY                 ; A+ X- Y+ BX+

    clc                                                 ; OK

    rts
.endproc

;;; summary: Load program
;;; in:
;;;   UBYTE   X=DEVICE           Device address
;;;   ZSTRING LOAD_COMMAND_NAME  Name of the command to load
;;; out:
;;;   C: 0: OK , 1: FAIL
;;; changed: A+ X+ Y+ C+ AX+ BX+ DL+
.proc LOAD_COMMAND
    ; require LOAD_COMMAND_NAME.LENGTH <= FILE_NAME_MAX_LENGTH
    stx z:DL                                            ; DL = X = DEVICE
    lda # LOAD_LA
    ldy # LOAD_SA
    jsr KERNAL_SETLFS

    ; AX := ZSTRING.NEW(DISK_COMMAND_TEXT).COPY_FROM(LOAD_COMMAND_NAME)
    lda # < DISK_COMMAND_TEXT
    sta z:AL
    lda # < DISK_COMMAND_TEXT
    sta z:AH
    ldx LOAD_COMMAND_NAME_LO
    ldy LOAD_COMMAND_NAME_HI
    jsr ZSTRING_AX_COPY_FROM_ZSTRING_XY

    ; + ".sh"
    ldx # < RESOURCE_STRING_DOT_SH
    ldy # > RESOURCE_STRING_DOT_SH
    jsr ZSTRING_AX_APPEND_ZSTRING_XY                    ; A+ X- Y+ BX+ CX+

    ; Load
    jsr ZSTRING_AX_LENGTH
    tya
    ldx z:AL
    ldy z:AH
    jsr KERNAL_SETNAM
    ldx z:DL                                              ; X = DL = DEVICE
    lda # KERNAL_LOAD_LOAD
    jsr KERNAL_LOAD                                     ; No need to close
    if_cc_then
        rts                                             ; OK
    else_end

    ; C = 1
    ; Load error
    cmp # KERNAL_ERROR_DEVICE_NOT_PRESENT
    if_eq_then
        ; Device not present
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        rts
    else_end

    ; Device present. (Attempt to) read (but not show) disk status.
    ldx z:DL                                            ; X = DL = DEVICE
    lda # 0
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    ldx # ERROR_NUMBER_COMMAND_NOT_FOUND
    sec                                                 ; FAIL

    rts
.endproc

;endregion

;region Disk status

;;; sumary: Process disk status:
;;; in:
;;;   A: FLAGS: PROCESS_DISK_STATUS_* flags
;;;   X: DA: Device Address
;;; out:
;;;   C: 0=OK 1=ERROR
;;; changed: A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc PROCESS_DISK_STATUS
    sta z:CL                                            ; CL = FLAGS
    clc                                                 ; C0
    and # PROCESS_DISK_STATUS_OPEN                      ; A+ N+ Z+
    if_ne_then
        jsr OPEN_DISK_COMMAND_CHANNEL                   ; A+ X+ Y+ C+
    else_end

    if_cc_then
        jsr READ_DISK_STATUS                            ; A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    else_end

    if_cc_then
        ; Check disk status: "00" is OK, else is error
        jsr CHECK_DISK_STATUS                           ; A+ X- Y- C+
        if
            lda z:CL                                    ; A = FLAGS
            and # PROCESS_DISK_STATUS_SHOW              ; A+ N+ Z+
            beq _end                                    ; ~SHOW -> No
            lda z:CL                                    ; A = FLAGS
            and # PROCESS_DISK_STATUS_ALWAYS            ; A+ N+ Z+
            bne _then                                   ; ALWAYS -> Yes
            bcc _end                                    ; C=0 -> No
            ; check C=1                                 ; Yes
        then
            jsr PUT_LINE_DISK_STATUS                    ; A+ X+ Y+ P- BX+
            ; check C=1
        else_end
    else_end

    lda z:CL                                            ; A = FLAGS
    and # PROCESS_DISK_STATUS_CLOSE                     ; A+ N+ Z+
    if_ne_then
        jsr CLOSE_DISK_COMMAND_CHANNEL                  ; A+ X+ Y+ P- DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    else_end

    rts
.endproc

;;; summary: Open disk command and status channel
;;; in:
;;;   X: DEVICE
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y- C+
;;; notes: Basically never fails because there is no file name
.proc OPEN_DISK_COMMAND_CHANNEL
    lda # DISK_COMMAND_LA_SA
    tay
    jsr KERNAL_SETLFS                                   ; A=LA X=DA Y=SA | A- X- Y-
    lda # 0
    jsr KERNAL_SETNAM                                   ; A- X- Y-
    jsr KERNAL_OPEN                                     ; A+ X+ Y- C+

    rts
.endproc

;;; summary: Close disk command and status channel
;;; in:
;;;   A: Device Address
;;; changed: A+ X+ Y+ P- DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc CLOSE_DISK_COMMAND_CHANNEL
    php
        lda # DISK_COMMAND_LA
        jsr KERNAL_CLOSE                                ; A+ X+ Y+ C+
        jsr CLRCHN                                      ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    plp

    rts
.endproc

;;; summary: Read disk status of device `A` into `DISK_STATUS_TEXT`.
;;; in:
;;;   X: DEVICE
;;; out:
;;;   C: 0=OK 1=ERROR
;;;   DISK_STATUS_TEXT: Disk status that has been read
;;; changed: A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc READ_DISK_STATUS
    ; DISK_STATUS_TEXT = ""
    lda # PETSCII_NUL
    sta DISK_STATUS_TEXT

    jsr CLRCHN                                          ; Just to be sure ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    ; Set input
    ldx # DISK_COMMAND_LA
    jsr KERNAL_CHKIN                                    ; A+ X+ Y- C+
    if_cs_then
        ; Cannot read disk status
        jsr CLRCHN                                      ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
        sec
        rts
    else_end

    ; Read line
    try
        from
            ldy # 0
        loop
            jsr GET_BYTE                                ; out A=RESULT | A+ X+ Y- C0 V+ N+ Z+
            bcs _catch                                  ; Error -> throw
            cmp # PETSCII_RETURN
            beq _end                                    ; break
            sta DISK_STATUS_TEXT , y
        next
            iny
            bne _loop                                   ; bra
        end
    catch_finally_end

    lda # PETSCII_NUL
    sta DISK_STATUS_TEXT , y

    ; Last chrin causes EOI and C=1

    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    rts
.endproc

;;; summary: Check disk status text for errors
;;; out:
;;;   C: 0=OK , 1=ERROR
;;; changed: A+ X- Y- C+
.proc CHECK_DISK_STATUS
    if
        lda DISK_STATUS_TEXT_CODE_0
        cmp # PETSCII_DIGIT_ZERO                        ; C+ N+ Z+
        bne _then
        lda DISK_STATUS_TEXT_CODE_1
        cmp # PETSCII_DIGIT_ZERO                        ; C+ N+ Z+
        beq _end
    then
        ; ! (DISK_STATUS_TEXT_CODE_0 = "0" & DISK_STATUS_TEXT_CODE_1 = "0")
        sec                                             ; ERROR

        rts
    else_end

    clc                                                 ; OK

    rts
.endproc

;;; summary: Print disk status
;;; changed: A+ X+ Y+ P- BX+
.proc PUT_LINE_DISK_STATUS
    php
        ldx # < DISK_STATUS_TEXT
        ldy # > DISK_STATUS_TEXT
        jsr PUT_LINE_ZSTRING_XY                         ; BX+
    plp

    rts
.endproc

;endregion

;region Build-in commands

;;; summary: Exit
.proc CMD_EXIT
    jsr RESET_FILE_IO

    ; Reset kernal indirects and vectors to system defaults
    jsr KERNAL_RESTOR                                   ; A+ X+ Y+

    ldx SAVE_S
    txs

    rts
.endproc

;;; summary: Load program
;;; in:
;;;   ARGV[1]: Program name
.proc CMD_LOAD
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX := ARGV[1]
    lda # 1
    jsr GET_AX_ARGV_A
    jsr ZSTRING_AX_LENGTH
    cpy # 0
    if_eq_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER

        rts
    else_end

    cpy # COMMAND_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    jsr LOAD_COMMAND_IF_NOT_ALREADY_LOADED

    rts
.endproc

;;; summary: List directory of system disk
.proc CMD_LS
    ldx GNUX_SYS_DEVICE
    jsr CMD_DIR
    rts
.endproc

;;; summary: List directory of work disk
.proc CMD_L
    ldx GNUX_WORK_DEVICE
    jsr CMD_DIR
    rts
.endproc

;;; summary: Send command to work disk
;;; changed: A+ X+ Y+ AX+
.proc CMD_DISK
    lda GNUX_ARGC_LO
    cmp # 2
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX : ZSTRING := ARGV[1]
    lda # 1
    jsr GET_AX_ARGV_A
    ; Y := AX.LENGTH
    jsr ZSTRING_AX_LENGTH
    if
        cpy # 0
        beq _then
        cpy # DISK_COMMAND_MAX_LENGTH + 1
        bcc _end                                        ; lt
    then                                                ; ge
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; Set output
    ldx # DISK_COMMAND_LA
    jsr KERNAL_CHKOUT                                   ; A+ X+ Y- C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    jsr PUT_ZSTRING_AX                                  ; BX+

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_SHOW | PROCESS_DISK_STATUS_ALWAYS
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN |  A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    rts
.endproc

;;; summary: Remove (delete, scratch) file
;;; changed: A+ X+ Y+ AX+
.proc CMD_RM
    lda GNUX_ARGC_LO
    cmp # 1
    if_eq_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; ARGC >= 2
    ; ARGV.FOR_EACH(START_AT=1, (A) -> DO_RM)
    ldx # < RM_LAMBDA
    ldy # > RM_LAMBDA
    jsr FOR_EACH_ARG

    rts
.endproc

;;; summary: Move (rename) file
;;; changed: A+ X+ Y+ AX+
.proc CMD_MV
    lda GNUX_ARGC_LO
    cmp # 3
    if_ne_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX = ARGV[1] = FROM
    lda # 1
    jsr GET_AX_ARGV_A
    jsr ZSTRING_AX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; AX = ARGV[2] = TO
    lda # 2
    jsr GET_AX_ARGV_A
    jsr ZSTRING_AX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_ge_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ldx # DISK_COMMAND_LA
    jsr KERNAL_CHKOUT                                   ; A+ X+ Y+ C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; "r"
    lda # PETSCII_LATIN_LETTER_R
    jsr KERNAL_CHROUT

    ; ":"
    lda # PETSCII_COLON
    jsr KERNAL_CHROUT

    ; TO
    jsr OUT_PUT_ZSTRING_AX

    ; "="
    lda # PETSCII_EQUALS_SIGN
    jsr KERNAL_CHROUT

    ; FROM
    ; AX = ARGV[1] = FROM
    lda # 1
    jsr GET_AX_ARGV_A
    jsr OUT_PUT_ZSTRING_AX

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    rts
.endproc

;;; summary: Print (cat) file
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DX+
.proc CMD_CAT
    ; Cat without arguments requires input redirection.
    ; Cat with arguments cancels any input redirection.
    lda GNUX_ARGC_LO
    cmp # 1
    if_eq_then
        ; Cat without arguments
        lda GNUX_IN_LA
        if_eq_then
            ; No input redirection
            ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
            jsr PUT_ERROR_X_NUMBER
            rts
        else_end

        ; Input redirection is active
        jsr STREAM_COPY_IN_TO_OUT

        rts
    else_end

    ; Like Gnu cat, close IN redirection if we have got a file
    lda GNUX_IN_LA
    if_ne_then
        jsr CLOSE                                       ; Does CLRCHN ; A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    else_end

    ; ARGC >= 2
    ; ARGV.FOR_EACH(START_AT=1, (A) -> DO_CAT)
    ldx # < CAT_LAMBDA
    ldy # > CAT_LAMBDA
    jsr FOR_EACH_ARG

    rts
.endproc

;;; summary: Show or change work disk
.proc CMD_WORK
    ; DX: POINTER TO UBYTE := & GNUX_SYS_DEVICE
    lda # < GNUX_WORK_DEVICE
    sta z:DL
    lda # > GNUX_WORK_DEVICE
    sta z:DH
    jsr SHOW_OR_CHANGE_DEVICE

    rts
.endproc

;;; summary: Show or change system disk
.proc CMD_SYS
    ; DX: POINTER TO UBYTE := & GNUX_SYS_DEVICE
    lda # < GNUX_SYS_DEVICE
    sta z:DL
    lda # > GNUX_SYS_DEVICE
    sta z:DH
    jsr SHOW_OR_CHANGE_DEVICE

    rts
.endproc

;endregion

;region Implementation of CMD_RM

.proc RM_LAMBDA
    jsr ZSTRING_AX_LENGTH
    cpy # FILE_NAME_MAX_LENGTH + 1
    if_eq_then
        ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ldx # DISK_COMMAND_LA
    jsr KERNAL_CHKOUT                                   ; A+ X+ Y- C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ; "s"
    lda # PETSCII_LATIN_LETTER_S
    jsr KERNAL_CHROUT

    ; ":"
    lda # PETSCII_COLON
    jsr KERNAL_CHROUT

    ; FILE
    jsr OUT_PUT_ZSTRING_AX

    ldx GNUX_WORK_DEVICE
    lda # PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0


    clc                                                 ; Continue for each
    rts
.endproc

;endregion

;region Implementation of CMD_CAT

;;; summary: CMD_CAT FOR_EACH_ARG LAMBDA
.proc CAT_LAMBDA
    ; Is ARGV[A].LENGTH < FILE_NAME_MAX_LENGTH ?
    jsr ZSTRING_AX_LENGTH
    if
        cpy # 0
        beq _then
        cpy # FILE_NAME_MAX_LENGTH + 1
        bcc _end                                        ; lt
    then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        clc                                             ; Continue for each
        rts
    else_end

    try
        ; Open
        lda # REDIRECT_INPUT_LA
        ldy # REDIRECT_INPUT_SA
        ldx GNUX_WORK_DEVICE
        jsr OPEN_IN_FILE_AX                                 ; A+ X+ Y+ C+
        if_cs_then
            ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
            jsr PUT_ERROR_X_NUMBER                          ; C1
            bcs _catch                                      ; throw
        else_end

        ldx GNUX_WORK_DEVICE
        lda # PROCESS_DISK_STATUS_SHOW
        jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
        bcs _catch                                          ; throw

        jsr STREAM_COPY_IN_TO_OUT

        ldx GNUX_WORK_DEVICE
        lda # PROCESS_DISK_STATUS_SHOW
        jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    catch_finally
        lda # REDIRECT_INPUT_LA
        jsr CLOSE                                           ; Does CLRCHN ; A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    end

    clc                                                     ; Continue for each

    rts
.endproc

;endregion

;region Implementation of CMD_L and CMD_LS

;;; summary: Directory listing of work or system disk
;;; in:
;;;   X: DEVICE: Device address
;;; changed: A+ X+ Y+ AX+ BX+ CX+ DL+
;;; notes:
;;;   We do not error check in the read-write loop for speed.
.proc CMD_DIR
    lda GNUX_ARGC_LO
    cmp # 3
    if_ge_then
        ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    stx z:DL                                            ; DL = X = DEVICE

    ; In case ARGC == 1
    ; AX := "$"
    lda # < RESOURCE_ZSTRING_DIR_NAME
    sta z:AL
    lda # > RESOURCE_ZSTRING_DIR_NAME
    sta z:AH

    lda GNUX_ARGC_LO
    cmp # 2
    if_eq_then
        ; ARGC == 2
        ; AX := ARGV[1]
        lda # 1
        jsr GET_AX_ARGV_A
        jsr ZSTRING_AX_LENGTH                           ; A+ X- Y+
        cpy # FILE_NAME_MAX_LENGTH + 1
        if_ge_then
            ldx # ERROR_NUMBER_FILE_NAME_TOO_LONG
            jsr PUT_ERROR_X_NUMBER
            rts
        else_end

        ; BX := AX
        lda z:AL
        sta z:BL
        lda z:AH
        sta z:BH

        ; AX := ZSTRING.NEW(DISK_COMMAND_TEXT)
        jsr ZSTRING_AX_NEW_DISK_COMMAND_TEXT            ; A+ X- Y- AX+

        ; + "$"
        lda # PETSCII_DOLLAR
        jsr ZSTRING_AX_APPEND_CHAR_A                    ; A+ X- Y+

        ; + ":"
        lda # PETSCII_COLON
        jsr ZSTRING_AX_APPEND_CHAR_A                    ; A+ X- Y+

        ; + ARGV[1]
        jsr ZSTRING_AX_APPEND_ZSTRING_BX                ; A+ X- Y+ CX+
    else_end

    ldx z:DL                                            ; X = DL = DEVICE
    lda # FILE_LA
    ldy # 0                                             ; SA load indicator
    jsr OPEN_IN_FILE_AX                                 ; in A=LA X=DA Y=0=LOAD AX=FILENAME | A+ X+ Y+ C+ DFLTN=0 DFLTO=3
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr PUT_ERROR_X_NUMBER
        rts
    else_end

    ldx z:DL                                            ; A = DL = DEVICE
    lda # PROCESS_DISK_STATUS_SHOW
    jsr PROCESS_DISK_STATUS                             ; Does CLRCHN | A+ X+ Y+ C+ BX+ CL+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    if_cs_then
        rts
    else_end

    try
        ; Load address
        ; Reading the first two bytes never gives error, so we need not check.
        jsr IN_CHKIN
        jsr IN_GET_BYTE                                 ; A+ X+ Y- C0 N+ V+ Z+
        jsr IN_GET_BYTE                                 ; A+ X+ Y- C0 N+ V+ Z+

        jsr OUT_CHKOUT                                  ; A+ X+ Y+ C+
        lda # PETSCII_RETURN
        jsr OUT_PUT_BYTE                                ; A+ X+ Y- C0 N+ V+ Z+

        from_loop OUTER
            jsr IN_CHKIN
            jsr IN_GET_BYTE                             ; A+ X+ Y- C0 N+ V+ Z+
            beq OUTER::_end                             ; End of directory -> break
            jsr IN_GET_BYTE                             ; A+ X+ Y- C0 N+ V+ Z+
            jsr IN_GET_BYTE                             ; A+ X+ Y- C0 N+ V+ Z+
            sta z:AL
            jsr IN_GET_BYTE                             ; A+ X+ Y- C0 N+ V+ Z+
            sta z:AH
            jsr AX_UWORD_TO_DECIMAL_AX_BX_CX            ; A+ X+ Y+ AX+ BX+ CX+
            jsr OUT_CHKOUT
            jsr OUT_PUT_ZSTRING_AX_BX_CX
            lda # PETSCII_SPACE
            jsr OUT_PUT_BYTE
            from_loop INNER
                jsr IN_CHKIN
                jsr IN_GET_BYTE 
                cmp # PETSCII_NUL
                beq INNER::_end                         ; break
                jsr OUT_CHKOUT                          ; A- X- Y- C+
                jsr OUT_PUT_BYTE
            next
                jmp INNER::_loop
            end

            jsr OUT_CHKOUT                              ; A- X- Y- C+
            lda # PETSCII_RETURN
            jsr OUT_PUT_BYTE

            ; STOP key pressed?
            jsr KERNAL_STOP
            beq _end                                    ; STOP key was pressed -> break

            jsr PAUSE_ON_SHIFT                          ; A+ X- Y-
        next
            jmp _loop
        end

        jsr OUT_CHKOUT                                  ; A- X- Y- C+
        lda # PETSCII_RETURN
        jsr OUT_PUT_BYTE
    catch_finally
        lda # FILE_LA
        jsr CLOSE                                       ; Does CLRCHN ; A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    end

    rts
.endproc

;endregion

;region Implementation of work and sys

;;; summary: Show or change work or system device
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;; changed: A+ X+ Y+ AX+ BX+
.proc SHOW_OR_CHANGE_DEVICE
    lda GNUX_ARGC_LO
    cmp # 1
    if_eq_then
        ; Show
        jsr SHOW_DEVICE

        rts
    else_end

    cmp # 2
    if_eq_then
        jsr CHANGE_DEVICE

        rts
    else_end

    ldx # ERROR_NUMBER_INCORRECT_ARGUMENTS
    jsr PUT_ERROR_X_NUMBER

    rts
.endproc

;;; summary: Show device number
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;; changed: A+ X+ Y+ AX+ BX+
.proc SHOW_DEVICE
    jsr OUT_CHKOUT                                      ; A- X- Y- C+
    lda # < RESOURCE_ZSTRING_DEVICE
    sta z:AL
    lda # > RESOURCE_ZSTRING_DEVICE
    sta z:AH
    jsr OUT_PUT_ZSTRING_AX

    ; AX := [DX]                                        ; DEVICE
    ldy # 0
    lda [DX],y
    sta z:AL
    sty z:AH

    jsr AX_UWORD_TO_DECIMAL_AX_BX_CX                    ; A+ X+ Y+ AX+ BX+

    jsr OUT_PUT_ZSTRING_AX_BX_CX

    lda # PETSCII_RETURN
    jsr OUT_PUT_BYTE

    rts
.endproc

;;; summary: Change device number, if possible, showing error if not.
;;; in:
;;;   DX: POINTER TO UBYTE: Address of device to show or change (GNUX_WORK_DEVICE or GNUX_SYS_DEVICE)
;;;   ARGV[1]: ZSTRING: Device number to change device
;;; out:
;;; changed:
;;;   A+ X+ Y+ AX+ BX+
.proc CHANGE_DEVICE
    ; A: UBYTE := ARGV[1].DECIMAL_TO_UBYTE              ; DEVICE
    lda # 1
    jsr GET_AX_ARGV_A
    jsr ZSTRING_AX_DECIMAL_TO_UBYTE_A                   ; out A = BL = NEW_DEVICE | A+ X- Y+ AX+ BL+
    if
        cmp # DEVICE_DISK_MIN
        bcc _then
        cmp # DEVICE_DISK_MAX + 1
        bcc _end
    then
        ldx # ERROR_NUMBER_WRONG_DEVICE
        jsr PUT_ERROR_X_NUMBER                          ; C = 1

        rts                                             ; FAIL
    else_end

    ; A = BL = NEW_DEVICE
    jsr IS_DISK_DEVICE_PRESENT                          ; A+ X+ Y+ AX+
    if_cc_then
        ; Device is present
        ; [DX] := NEW_DEVICE
        lda z:BL
        ldy # 0
        sta [DX],y
    else_end

    rts
.endproc

;;; summary: Probe if disk device is present, showing error if not.
;;; in:
;;;   BL: DEVICE
;;; changed: A+ X+ Y+ AX+
.proc IS_DISK_DEVICE_PRESENT
    jsr CLOSE_DISK_COMMAND_CHANNEL
    ldx z:BL
    jsr OPEN_DISK_COMMAND_CHANNEL                       ; in X=DEVICE | A+ X+ Y+ C+
    ; Open on non-existing device will not fail (because no bus I/O because file name), so no need to check C here.
    ; Use CHKOUT to check if device is present; do not use CHKIN because this will hang when the device is not present.
    ldx # DISK_COMMAND_LA
    jsr KERNAL_CHKOUT                                   ; A- X- Y- C+
    if_cs_then
        ldx # ERROR_NUMBER_DEVICE_NOT_PRESENT
        jsr PUT_ERROR_X_NUMBER                          ; C=1
        rts                                             ; FAIL
    else_end

    ; C=0                                               ; OK

    rts
.endproc

;endregion

;region ZSTRING

;;; summary: Make AX a new empty string on DISK_COMMAND_TEXT
;;; changed: A+ X- Y- AX+
.proc ZSTRING_AX_NEW_DISK_COMMAND_TEXT
    lda # < DISK_COMMAND_TEXT
    sta z:AL
    lda # > DISK_COMMAND_TEXT
    sta z:AH
    lda # PETSCII_NUL
    sta DISK_COMMAND_TEXT

    rts
.endproc


;;; summary: String length
;;; in:
;;;   AX: String, nul-terminated
;;; out:
;;;   Y: Length of string
;;; changed: A+ X- Y+
.proc ZSTRING_AX_LENGTH
    from
        ldy # 0
    loop
        lda [AX],y
        beq _end                                        ; break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Compare strings
;;; in:
;;;   AX: ZSTRING: Left
;;;   BX: ZSTRING: Right
;;; out:
;;;   Z: Is equal? 0 = no 1=yes
;;; changed: A+ X- Y+ Z+
.proc ZSTRING_AX_COMPARE_ZSTRING_BX
    from
        ldy # 0
    loop
        lda [AX],y
        cmp [BX],y
        if_ne_then
            rts
        else_end
    next
        cmp # PETSCII_NUL
        beq _end
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: Append char to string
;;; in:
;;;   A: BYTE: Source character
;;;   AX: ZSTRING: Target string
;;; changed: A+ X+ Y+
.proc ZSTRING_AX_APPEND_CHAR_A
    tax
        from
            ldy # 0
        loop
            lda [AX],y
            beq _end                                    ; break
        next
            iny
            bne _loop                                   ; bra
        end
    txa
    sta [AX],y
    iny
    lda # PETSCII_NUL
    sta [AX],y

    rts
.endproc

;;; summary: Append string
;;; in:
;;;   ZSTRING X#Y  SOURCE
;;;   ZSTRING AX   TARGET
;;; changed: A+ X- Y+ BX+ CX+
.proc ZSTRING_AX_APPEND_ZSTRING_XY
    stx z:BL
    sty z:BH
    jsr ZSTRING_AX_APPEND_ZSTRING_BX                    ; A+ X- Y+ CX+

    rts
.endproc

;;; summary: Append string
;;; in:
;;;   AX: ZSTRING: TARGET
;;;   BX: ZSTRING: SOURCE
;;; changed: A+ X- Y+ CX+
.proc ZSTRING_AX_APPEND_ZSTRING_BX
    from
        jsr ZSTRING_AX_LENGTH                           ; A+ X- Y+
        sty z:CH                                        ; CH = I_TARGET
        ldy # 0
        sty z:CL                                        ; CL = I_SOURCE
    loop
        ; TARGET[I_TARGET] := SOURCE[I_SOURCE]
        ldy z:CL
        lda [BX], y                                     ; A = SOURCE[I_SOURCE]
        beq _end                                        ; EOS -> break
        ldy z:CH
        sta [AX],y                                      ; TARGET[I_TARGET] = A
    next
        inc z:CL                                        ; I_SOURCE++
        inc z:CH                                        ; I_TARGET++
        bne _loop                                       ; bra
    end

    ; A = PETSCII_NUL
    ; TARGET[I_TARGET] := PETSCII_NUL
    ldy z:CH
    sta [AX],y

    rts
.endproc

;;; summary: Copy string
;;; in:
;;;   AX: TARGET
;;;   BX: SOURCE
;;; changed: A+ X- Y+ BX+
.proc ZSTRING_AX_COPY_FROM_ZSTRING_XY
    stx z:BL
    sty z:BH
    jsr ZSTRING_AX_COPY_FROM_ZSTRING_BX                 ; A+ X- Y+

    rts
.endproc

;;; summary: Copy string
;;; in:
;;;   AX: TARGET
;;;   BX: SOURCE
;;; changed: A+ X- Y+
.proc ZSTRING_AX_COPY_FROM_ZSTRING_BX
    from
        ldy # 0
    loop
        lda [BX], y
        sta [AX],y
        beq _end                                        ; EOS -> break
    next
        iny
        bne _loop                                       ; bra
    end

    rts
.endproc

;endregion

;region Low-level I/O

;;; summary: Set IN/OUT back to keyboard and screen. Clear STATUS.
;;; changed: A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc CLRCHN
    jsr KERNAL_CLRCHN                                   ; A+ X+ Y- C+ DFLTN=0 DFLTO=3
    lda # 0
    sta z:ZPKERNAL_STATUS
    sta IN_STATUS
    sta OUT_STATUS
    clc                                                 ; C = 0

    rts
.endproc

;;; summary: Get byte from input channel
;;; out:
;;;   A: Byte read
;;;   C: Error? 0: FALSE , 1: TRUE
;;; changed: A+ X+ Y- C+ N+ V+ Z+ STATUS+
.proc GET_BYTE
    jsr KERNAL_CHRIN                                    ; A+ X+ Y- C0 N+ V+ Z+
    tax
        jsr KERNAL_READST                               ; A+ C+ N+ V- Z+
        clc
        if_ne_then
            sec
        else_end
    txa

    rts
.endproc

;;; summary: Send byte to output channel
;;; in:
;;;   A: Byte to write
;;;   C: Error? 0: FALSE , 1: TRUE
;;; changed: A+ X- Y- C+ N+ V+ Z+ STATUS+
.proc PUT_BYTE
    jsr KERNAL_CHROUT                                   ; A- X- Y- C0 N+ V+ Z+
    jsr KERNAL_READST                                   ; A+ C+ N+ V- Z+
    clc
    if_ne_then
        sec
    else_end

    rts
.endproc

;;; summary: Open file
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: Logical file Address (LA)
;;;   X: Device Address (DA)
;;;   Y: Secondary Address (SA)
;;; changed: A+ X+ Y+ C+
;;; notes:
;;;   Open basically never fails if there is no file name, only the CHKIN/CHKOUT after it will fail if the device is not present.
.proc OPEN_FILE_AX
    jsr KERNAL_SETLFS                                   ; A=LA X=DA Y=SA | A- X- Y-
    jsr ZSTRING_AX_LENGTH                               ; A+ X- Y+
    tya
    ldx z:AL
    ldy z:AH
    jsr KERNAL_SETNAM                                   ; A=NAME.LENGTH X=<NAME Y=>NAME | A- X- Y-
    jsr KERNAL_OPEN                                     ; A+ X+ Y- C+

    rts
.endproc

;;; summary: Write string to output channel with RETURN
;;; in:
;;;   X#Y: ZSTRING: String to write
;;; out:
;;;   C: Error? 0: FALSE , 1: TRUE
;;; changed: A+ X- Y+ C+ N+ V+ Z+ AX+
.proc PUT_LINE_ZSTRING_XY
    jsr PUT_ZSTRING_XY
    lda # PETSCII_RETURN
    jsr PUT_BYTE

    rts
.endproc

;;; summary: Write string to output channel
;;; in:
;;;   X#Y: ZSTRING: String to write
;;; out:
;;;   C: Error? 0: FALSE , 1: TRUE
;;; changed: A+ X- Y+ C+ N+ V+ Z+ AX+
.proc PUT_ZSTRING_XY
    stx z:AL
    sty z:AH
    jsr PUT_ZSTRING_AX

    rts
.endproc

;;; summary: Write string to output channel
;;; in:
;;;   AX: ZSTRING: String to write
;;; out:
;;;   C: Error? 0: FALSE , 1: TRUE
;;; changed: A+ X- Y+ C+ N+ V+ Z+
.proc PUT_ZSTRING_AX
    try
        from
            ldy # 0
        loop
            lda [AX],y                                  ; A+ N+ Z+
            beq _end                                    ; EOS -> break
            jsr PUT_BYTE                                ; A+ X- Y- C+ N+ V+ Z+
            bcs _catch
        next
            iny
            bne _loop                                   ; bra
        end
    catch_finally_end

    rts
.endproc

;endregion

;region File

;;; summary: Open file for input
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: Logical file Address (LA)
;;;   X: Device Address (DA)
;;;   Y: Secondary Address (SA)
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ BL+
.proc OPEN_IN_FILE_AX
    sta z:BL                                            ; BL = A = LA
    lda GNUX_IN_LA
    if_ne_then
        ; Already open
        sec
    else_end

    lda z:BL                                            ; A = BL = LA
    jsr OPEN_FILE_AX                                    ; A+ X+ Y+
    if_cc_then
        lda z:BL                                        ; A = BL = LA
        sta GNUX_IN_LA
    else_end

    rts
.endproc

;;; summary: Open file for output
;;; in:
;;;   AX: ZSTRING: File name
;;;   A: Logical file Address (LA)
;;;   X: Device Address (DA)
;;;   Y: Secondary Address (SA)
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ BL+
.proc OPEN_OUT_FILE_AX
    sta z:BL                                            ; BL = A = LA
    lda GNUX_OUT_LA
    if_ne_then
        ; Already open
        sec
    else_end

    lda z:BL                                            ; A = BL = LA
    jsr OPEN_FILE_AX                                    ; A+ X+ Y+ C+
    if_cc_then
        lda z:BL                                        ; A = BL = LA
        sta GNUX_OUT_LA
    else_end

    rts
.endproc

;;; summary: Close file, handling redirection. Does CLRCHN.
;;; in:
;;;   A: Logical file Address (LA)
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X+ Y+ C+ DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc CLOSE
    ldx # 0
    cmp GNUX_IN_LA
    if_eq_then
        stx GNUX_IN_LA
    else_end

    cmp GNUX_OUT_LA
    if_eq_then
        stx GNUX_OUT_LA
    else_end

    tay
        jsr CLRCHN                                      ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
    tya

    jsr KERNAL_CLOSE                                    ; in A=LA | A+ X+ Y+ C+
    ; May fail on write buffered character

    rts
.endproc

;;; summary: Back to default file I/O
;;; changed: A+ X+ Y- DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0
.proc RESET_FILE_IO
    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    ; Close all open files
    from_loop
        ldx z:ZPKERNAL_LDTND
        beq _end
        lda KVAR_LAT
        jsr KERNAL_CLOSE                                ; A+ X+ Y+ C+
    next
        jmp _loop
    end

    ; Redirect input & output inactive
    lda # 0
    sta GNUX_IN_LA                                      ; 0 = Keyboard
    sta GNUX_OUT_LA                                     ; 0 = Screen
    sta IN_STATUS
    sta OUT_STATUS

    rts
.endproc

;;; summary: Select IN as input channel
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A+ X+ Y- C+ STATUS=0
.proc IN_CHKIN
    clc
    ldx # 0
    stx z:ZPKERNAL_STATUS
    ldx GNUX_IN_LA
    if_ne_then
        jsr KERNAL_CHKIN                                ; A+ X+ Y- C+
    else_end

    rts
.endproc

;;; summary: Select OUT as output channel, with redirection.
;;; out:
;;;   C: 0: OK , 1: ERROR
;;; changed: A- X+ Y- C+
.proc OUT_CHKOUT
    pha
        ldx # 0
        stx z:ZPKERNAL_STATUS
        ldx GNUX_OUT_LA
        if_ne_then
            jsr KERNAL_CHKOUT                           ; A+ X+ Y- C+
        else_end
    pla

    rts
.endproc

;endregion

;region IN

;;; summary: Has a timeout occured on IN?
;;; out:
;;;   C: 0: FALSE , 1: TRUE
;;; changed: A- X- Y- C+ N+ V- Z+
;;; notes:
;;;   In case you already know device is present.
.proc IN_IS_TIMEOUT
    pha
        lda IN_STATUS
        ; C := bit 2 KERNAL_IO_ERROR_TIMEOUT_READ
        lsr
        lsr
    pla

    rts
.endproc

;;; summary: Get byte from IN
;;; out:
;;;   A: Byte read
;;;   C: Error (timeout, eoi, device not present): 0: FALSE , 1: TRUE
;;; changed: A+ X+ Y- C0 N+ V+ Z+ IN_STATUS+
;;; notes:
;;;   Check `OUT_STATUS` for any specific error.
.proc IN_GET_BYTE
    jsr KERNAL_CHRIN                                    ; A+ X+ Y- C0 N+ V+ Z+
    tax
        jsr KERNAL_READST                               ; A+ C+ N+ V- Z+
        clc
        sta IN_STATUS
        if_ne_then
            sec
        else_end
    txa

    rts
.endproc

;endregion

;region OUT

;;; summary: Has a timeout occured on `OUT`?
;;; out:
;;;   C: 0: FALSE , 1: TRUE
;;; changed: A- X- Y- C+ N+ V- Z+
;;; notes:
;;;   In case you already know device is present.
.proc OUT_IS_TIMEOUT
    pha
        lda OUT_STATUS
        ; C := bit 1 KERNAL_IO_ERROR_TIMEOUT_WRITE
        lsr
    pla

    rts
.endproc

;;; summary: Put byte to `OUT`
;;; in:
;;;   A: Byte to write
;;; out:
;;;   C: Error: 0: FALSE 1: TRUE
;;; changed: A+ X- Y- C0 OUT_STATUS+
;;; notes:
;;;   Check `OUT_STATUS` for any error.
.proc OUT_PUT_BYTE
    jsr KERNAL_CHROUT                                   ; A- X- Y- C0 N+ V+ Z+
    jsr KERNAL_READST                                   ; A+ X- Y- C+ N+ V- Z+
    clc                                                 ; OK
    sta OUT_STATUS
    if_ne_then
        sec
    else_end

    rts
.endproc

;;; summary: Write string to output channel (OUT), with error handling
;;; in:
;;;   AX: ZSTRING: String to write
;;; out:
;;;   C: 0=OK 1=FAIL
;;; changed: A+ X- Y+ C+ N+ V+ Z+ OUT_STATUS+
.proc OUT_PUT_ZSTRING_AX
    try
        clc                                             ; If input string is empty, then OUT_PUT_BYTE is never called and C is not set.
        from
            ldy # 0
        loop
            lda [AX],y                                  ; A+ N+ Z+
            beq _end                                    ; NUL -> break
            jsr OUT_PUT_BYTE                            ; A+ X- Y- C+ N+ V+ Z+ OUT_STATUS+
            bcs _catch                                  ; Error -> throw
        next
            iny
            bne _loop                                   ; bra
        end
    catch_finally_end

    rts
.endproc

;;; summary: Write ZSTRING in AX, BX, CX
;;; in:
;;;   AX, BX, CX: ZSTRING: Source
;;; out:
;;;   C: 0: OK , 1: FAIL
;;; changed: A+ X- Y+ C+ N+ V+ Z+ OUT_STATUS+
;;; notes:
;;;   Do not change DX
.proc OUT_PUT_ZSTRING_AX_BX_CX
    try
        clc                                             ; If input string is empty, then OUT_PUT_BYTE is never called and C is not set.
        from
            ldx # 0
        loop
            lda z:AX , x
            beq _end                                    ; NUL -> break
            jsr OUT_PUT_BYTE                            ; A+ X- Y- C+ N+ V+ Z+ OUT_STATUS+
            bcs _catch                                  ; error -> throw
        next
            inx
            bne _loop                                   ; bra
        end
    catch_finally_end

    rts
.endproc

;endregion

;region IN/OUT

;;; summary: Clear OUT status
;;; changed: A+ X- Y- C- N+ V- Z+ IN_STATUS=0 OUT_STATUS=0
.proc IN_OUT_CLEAR_STATUS
    lda # 0
    sta IN_STATUS
    sta OUT_STATUS

    rts
.endproc

;;; summary: Copy IN to OUT
;;; notes:
;;;   `<SHIFT>` pauses
;;;   `<STOP>` cancels. On cancel the channels are cleared.
;;;   What makes this routine a bit complicated is the fact that you get EOI on the last byte when calling `chrin`
;;;   So we still need to write that byte/char.
;;;   Basically, an empty file is not possible with CBM DOS, there are always at least 2 bytes.
;;;   We check for errors IN_CHKIN and OUT_CHKOUT only once for speed.
.proc STREAM_COPY_IN_TO_OUT
    jsr IN_OUT_CLEAR_STATUS                             ; A+
    try
        jsr CLRCHN                                      ; A- X- Y- C0 N+ V+ Z+
        jsr IN_CHKIN                                    ; A- X- Y- C+
        bcs _catch                                      ; error -> throw
        jsr OUT_CHKOUT                                  ; A- X- Y- C+
        bcs _catch                                      ; error -> throw
        from_loop COPY
            bit IN_STATUS                               ; V+
            bvs COPY::_end                              ; EOI -> break
            jsr IN_CHKIN                                ; A- X- Y- C+
            jsr IN_GET_BYTE                             ; A+ X+ Y- C0 N+ V+ Z+ IN_STATUS+
            jsr IN_IS_TIMEOUT                           ; A- X- Y- C+
            bcs _catch                                  ; error -> throw
            jsr OUT_CHKOUT                              ; A- X- Y- C+
            jsr OUT_PUT_BYTE                            ; A+ X+ Y- C0 N+ V+ Z+ OUT_STATUS+
            bcs _catch                                  ; error -> throw
            jsr OUT_IS_TIMEOUT                          ; A- X- Y- C+
            bcs _catch                                  ; error -> throw

            ; STOP key pressed?
            jsr KERNAL_STOP                             ; A+ X- Y- C+ N+ V- Z+
            if_eq_then
                sec
                bcs COPY::_end                          ; Cancel -> break
            else_end

            jsr PAUSE_ON_SHIFT                          ; A+ X- Y-
        next
            jmp _loop
        end

        ; check C = 0

    catch_finally_end
    
    rts
.endproc

;endregion

;region Conversion

;;; summary: Decimal string to unsigned byte
;;; in:
;;;   AX: ZSTRING: Decimal number string
;;; out:
;;;   A : UBYTE: Binary representation of input
;;;   BL: = A
;;; changed:
;;;   A+ X- Y+ BL+
;;; notes:
;;;   We do not check for valid input.
;;; cycles:
;;;   Depends on length of source:
;;;   1: 66
;;;   2: 113
;;;   3: 160
.proc ZSTRING_AX_DECIMAL_TO_UBYTE_A
    from
        ldy # 0
        sty z:BL
    loop
        lda [AX],y
        beq _end                                        ; A = NUL -> break
        ; BL := 10 * BL = (8 + 2) * BL = 8 * BL + 2 * BL = BL << 3 + BL + BL
        lda z:BL
        asl
        asl
        asl
        ; C=0
        adc z:BL
        adc z:BL
        sta z:BL
        ; BL += AX[Y] - '0'
        lda [AX],y
        ; "0" = $30 <= A <= "9" = $39
        sec
        sbc # PETSCII_DIGIT_ZERO
        ; 0 <= A <= 9 ; C = 1
        clc
        adc z:BL
        sta z:BL
    next
        iny
        bne _loop                                       ; bra
    end

    lda z:BL

    rts
.endproc

;;; summary: Unsigned word (binary) to decimal string
;;; in:
;;;  AX: WORD: VALUE
;;; out:
;;;   AX,BX,CX: ZSTRING: decimal representation of VALUE
;;; changed: A+ X+ Y+ AX+ BX+ CX+
;;; notes:
;;;   Disables interrupts because it uses Decimal mode and Kernal interrupt & nmi routines use ADC & SBC.
;;;   Result has no leading zeros.
;;;   It uses a simple fixed loop that shifts the bits out of the binary value
;;;   one at a time and adds it to an intermediate result that is being doubled
;;;   (in BCD) on each iteration. Why? Because this is more efficient than the
;;;   traditional method of subtracting in a loop: this routine ~900 cycles
;;;   v.s. up to 2000 cycles or more.
;;;   Source value is destroyed.
;;;   Reference: book "6502 Instruction Set Guide" written by  Andrew John Jacobs and edited by Dion Olsthoorn, October 2021, chapter "Coding Algorithms", section "Decimal Arithmetic", pp. 27.
;;;   Do not use DX.
.proc AX_UWORD_TO_DECIMAL_AX_BX_CX
    ; Zero out result
    ldy # 0
    sty z:CL                                            ; LO
    sty z:BH                                            ; MED
    sty z:BL                                            ; HI
    ldx # 16                                            ; Bit counter
    sei
        sed
            from_loop
                asl z:AL
                rol z:AH
                lda z:CL
                adc z:CL
                sta z:CL
                lda z:BH
                adc z:BH
                sta z:BH
                lda z:BL
                adc z:BL
                sta z:BL
            next
                dex
                bne _loop
            end
        cld
    cli

    ; AX = 0

    ; BL,BH,CL is BCD representation of VALUE, hi nybble of BL is %0000
    ; |  BL   |   BH  |   CL  |
    ; |hn |ln |hn |ln |hn |ln |
    ; | 0 |0-9|0-9|0-9|0-9|0-9|

    from_loop
        lda z:BX,x
        bne _end                                        ; A != 0 -> break
    next
        ; A=0
        inx
        cpx # 3
        bne _loop
    end

    ; X <= 3 ; Y=0
    ; (x = 3) = (A = 0)
    pha
        lsr
        lsr
        lsr
        lsr
        if_ne_then
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
        else_end
    pla
    and # $0F
    ora # PETSCII_DIGIT_ZERO
    sta AX,y
    iny
    cpx # 2
    if_lt_then
        inx
        from_loop
            lda z:BX,x
            lsr
            lsr
            lsr
            lsr
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
            lda z:BX,x
            and # $0F
            ora # PETSCII_DIGIT_ZERO
            sta AX,y
            iny
        next
            inx
            cpx # 3
            bcc _loop
        end
    else_end

    lda # PETSCII_NUL
    sta AX,y

    rts
.endproc

;endregion

;region Branch to subroutine

;;; summary Jump to subroutine indirect
;;; in:
;;;   DX: Address of souroutine
.proc JSR_INDIRECT_DX
    jmp [DX]
.endproc

;endregion

;region Keyboard

;;; summary: Pause on SHIFT
;;; changed: A+
.proc PAUSE_ON_SHIFT
    from_loop
        lda KVAR_SHFLAG
        ; KVAR_SHFLAG = $028D Shift key indicator. Bits:
        ; Bit #0: 1 = One or more of left Shift, right Shift or Shift Lock is currently being pressed or locked.
        ; Bit #1: 1 = Commodore is currently being pressed.
        ; Bit #2: 1 = Control is currently being pressed.
        ; Other bits are 0.
        beq _end                                        ; Not SHIFT, CONTROL, COMMODORE Key pressed -> break
    next
        bne _loop
    end

    rts
.endproc

;endregion

;region Error handling

;;; summary: Print error message of error number to screen. Does CLRCHN.
;;; in:
;;;   X: Error number
;;; out:
;;;   C=1
;;; changed: A+ X+ Y+ AX+
.proc PUT_ERROR_X_NUMBER
    stx z:AL

    jsr CLRCHN                                          ; A+ X+ Y- C0 DFLTN=0 DFLTO=3 STATUS=0 IN_STATUS=0 OUT_STATUS=0

    ldx z:AL
    ldy TABLE_ERROR_MESSAGE_HI,x
    lda TABLE_ERROR_MESSAGE_LO,x
    tax
    jsr PUT_LINE_ZSTRING_XY                             ; A+ X- Y+ C+ AX+

    sec                                                 ; FAIL

    rts
.endproc

;endregion

;region NMI handler

;;; summary: My NMI handler.
;;; notes:
;;;   We catch <RUN STOP> + <RESTORE> else we go back to BASIC.
.proc MY_NMI_HANDLER
    ; check I = 1

    ; Check for and prevent re-entry
    bit NMI_ENTRY_COUNT
    if_mi_then
        ; Already in an NMI call (not sure how this could happen, maybe on bouncing RESTORE key)
        rti
    else_end

    ; First entry
    pha
    txa
    pha
        tya
        pha
            ; Disable all CIA-2 interrupts (why?)
            lda # $7F
            sta CIA_2_ICR
            ; Process any pending CIA-2 interrupt.
            ; NMI occured?
            ldy CIA_2_ICR
            if_mi_then
                ; NMI occured yes
                jmp KERNAL_NNMI20                       ; Continue at original Kernal NMI handler
            else_end

            ; NMI occured no
            ; RESTORE key was pressed
            ; STOP key pressed? Z=1 (eq): yes, Z=0 (ne): no
            jsr KERNAL_STOP
            if_ne_then
                ; STOP key was not pressed
                jmp KERNAL_NNMI20                       ; Continue at original Kernal NMI handler
            else_end

            ; STOP key was pressed

            dec NMI_ENTRY_COUNT                         ; FALSE -> TRUE: prevent re-entry

            ; Set text screen base to default (in case it got changed).
            lda # >SCREEN_TEXT_RAM_BASE
            sta KVAR_HIBASE

            ; Save and restore colors because called Kernal routine changes them.
            ; We cannot use configured colors because a program could use different colors
            lda KVAR_COLOR
            pha
                lda VIC_EC
                pha
                    lda VIC_B0C
                    pha
                        jsr KERNAL_IOINIT
                        ; Kernal ioinit:
                        ; Also sets memory configuration to default: BASIC ROM, IO DEVICES, KERNAL ROM, Datasette output off motor off
                        jsr KERNAL_CINT
                        ; Kernal cint:
                        ; Also sets default I/O: output dflto := 3 (screen), input dfltn := 0 (keyboard)
                    pla
                    sta VIC_B0C
                pla
                sta VIC_EC
            pla
            sta KVAR_COLOR

            ; Restore stack pointer to where it was on NMI.
            ldx SAVE_S
            txs

            ; Enable interrupts so we can do file I/O.
            cli

            jsr RESET_FILE_IO

            inc NMI_ENTRY_COUNT                         ; TRUE -> FALSE: allow entry
            jmp RUN                                     ; Resume
.endproc

;endregion

;region Maps

;;; summary: Map command name to number
;;; in:
;;;   AX: ZSTRING: Candidate command name
;;; out:
;;;   X: Command number, if Z=1
;;;   Z: 1 = found , 0 = not found
;;; changed: A+ X- Y+ BX+
.proc MAP_AX_COMMAND_NAME_TO_COMMAND_NUMBER
    from
        ldx # TABLE_COMMAND_NAME_SIZE - 1
    loop
        lda TABLE_COMMAND_NAME_LO, x
        sta z:BL
        lda TABLE_COMMAND_NAME_HI, x
        sta z:BH
        jsr ZSTRING_AX_COMPARE_ZSTRING_BX               ; A+ X- Y+ Z+ BX+
        beq _end                                        ; Z=1 -> equal -> break
    next
        dex
        bpl _loop
        ; N=1 Z=0 -> Exhausted
    end

    rts
.endproc

;endregion

;region Enumerate arguments

;;; summary: Enumerate arguments, if any, starting from 1
;;; in:
;;;   X#Y: LAMBDA: Address of callback procedure
;;; notes:
;;;   Let LAMBDA return in C 
;;; changed: A+ X- Y+ BX+
.proc FOR_EACH_ARG
    ; We use the stack for count each argument 1 .. ARGC-1, because lambda can use all registers.
    stx FOR_EACH_ARG_LAMBDA_LO
    sty FOR_EACH_ARG_LAMBDA_HI
    from
        lda # 1
        pha
    loop
        pla
        pha
        ; AX := ARGV[A]
        jsr GET_AX_ARGV_A                               ; A+ X- Y+ AX+
        jsr FOR_EACH_ARG_CALL_LAMBDA                    ; A? X? Y? C+ AX? BX? CX? DX?
        bcs _end                                        ; C=1 -> break
    next
        pla
        tax
        inx
        cpx GNUX_ARGC_LO
        beq _end
        txa
        pha
        bne _loop                                       ; bra
    end

    rts
.endproc

;;; summary: 
.proc FOR_EACH_ARG_CALL_LAMBDA
    jmp [FOR_EACH_ARG_LAMBDA]
.endproc

;endregion
